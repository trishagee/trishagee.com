{
 "disqus_url" : "http://trishagee.github.io/post/java_specifics/",
 "disqus_title" : "Java Specifics",
 "Title": "Java Specifics",
 "Pubdate": "2007-07-07",
 "Slug": "java_specifics",
 "Section": "post"
}
When I first started playing with Java 1.5, I thought <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html">generics</a> were the best thing since sliced bread.  No more untidy casting, lovely type-safe Collections, and when combined with the <a href="http://java.sun.com/j2se/1.5.0/docs/guide/language/foreach.html">new for loop</a>, a lot of the tedious tasks associated with Collections became easier and, most importantly, aesthetically pleasing.<br/><br/><br/><br/>Consider the old code:<br/><br/><pre><br/>	    List list = new ArrayList();<br/>	    list.add(new Integer(1));<br/>	    Integer integer = (Integer)list.get(0);<br/><br/>	    for (Iterator i = list.iterator(); i.hasNext(); ) {<br/>	    	Integer number = (Integer)i.next();<br/>	    	number.intValue();<br/>	    }<br/></pre><br/><br/>And the new:<br/><pre><br/>	    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();<br/>	    list.add(new Integer(2));<br/>	    Integer integer = list.get(0);<br/><br/>	    for (Integer number : list) {<br/>	    	number.intValue();<br/>	    }<br/></pre><br/><br/>See?  Much prettier.  OK so it's a silly little example but when you apply it to all the places you use things like Collections it does make life a lot easier, especially when you consider that now you *know* what's in that List that comes back from some method that you're not familiar with.<br/><br/><br/><br/>Nearly two years on from the first time I started using them, I run into an issue - they're not generic at all.  They're specific.  The point about generics as far as I can figure out is type-safety - they remove the need to cast everything everywhere.  Which is great, until you actually want a little flexibility in your types.  So, you can have the code above which adds and retrieves Integers from a list, knowing that it's perfectly fine to get objects from that list and treat them as Integers because that's exactly what they are.  But what you can't do is assign a List of some subtype to a List of one if its supertypes:<br/><br/><pre><br/>	public List&lt;Integer&gt; getIntegers() {<br/>		List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;();<br/>		integers.add(new Integer(1));<br/>		return integers;<br/>	}<br/><br/>	...<br/><br/>	public void assignList() {<br/>		List&lt;Number&gt; numbers = getIntegers(); //compiler error - Type mismatch<br/>		//or<br/>		numbers = new ArrayList&lt;Integer&gt;(); //compiler error - Type mismatch<br/>	}<br/></pre><br/><br/>OK fine, it's a bit confusing but it makes sense if you think about it.  A good example is provided in <a href="http://www.ibm.com/developerworks/java/library/j-jtp01255.html">this article</a>, which explains that if you're expecting a Collection of Numbers, you might expect to be able to add a Float to it, but if lurking under the covers you've assigned a List of Integers to it, it is incorrect to add a Float to it.<br/><br/><br/><br/>So what about wildcards?  Aren't they supposed to overcome this issue?  Well, <a href="http://www.netalive.org/swsu/archives/2005/07/generics_wildca.html">sort of</a>.  Wildcards in generics means you can do the following:<br/><br/><pre><br/>		List&lt;? extends Number&gt; numbers = getIntegers();<br/>		//or<br/>		numbers = new ArrayList&lt;Integer&gt;();<br/></pre><br/><br/>and this will not give a compiler error.  But then you can't do:<br/><br/><pre><br/>		List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();<br/>		numbers.addAll(new ArrayList&lt;Integer&gt;()); //compiler error<br/>		numbers.add(new Integer(1)); //compiler error<br/></pre><br/><br/>So you can use a wildcarded Collection to represent that you know that Collection is going to be some Collection that contains something that is a subclass of Number (for example), but not to say that the Collection can contain any mix of items that are a sublasses of number.<br/><br/><br/><br/>OK... what do I need to remember to prevent confusion in future?<br/><br/><br/><br/>Well, looks like we use:<br/><pre><br/>		List&lt;Number&gt; numbers = new ArrayList&lt;Number&gt;();<br/>		numbers.add(new Integer(1));<br/>		numbers.add(new Double(1));<br/></pre><br/>if you want your collection to contain a mix of items that are subclasses of your specified generic type.  But you might have to use something like <code>addAll</code> to insert the contents of some other List into it, as you can't assign Lists of subclasses to it.<br/><br/><br/><br/>If you want to assign Lists that have a generic type that's a subclass, then you want to use wildcards:<br/><pre><br/>		List&lt;? extends Number&gt; numbers = getIntegers();<br/>		//or<br/>		numbers = new ArrayList&lt;Integer&gt;();<br/></pre><br/><br/>So, easy then.  No idea what I got so confused about.
