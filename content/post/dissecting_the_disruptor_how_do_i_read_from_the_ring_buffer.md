{
 "disqus_url" : "http://trishagee.github.io/post/dissecting_the_disruptor_how_do_i_read_from_the_ring_buffer/",
 "disqus_title" : "Dissecting the Disruptor: How do I read from the ring buffer?",
 "Title": "Dissecting the Disruptor: How do I read from the ring buffer?",
 "Pubdate": "2011-06-28",
 "Slug": "dissecting_the_disruptor_how_do_i_read_from_the_ring_buffer",
 "Section": "post"
}
The next in the series of understanding <a href="http://code.google.com/p/disruptor/">the Disruptor pattern</a> developed at <a href="http://www.lmaxtrader.com/">LMAX</a>.<br /><br />After the <a href="http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-whats-so-special.html">last post</a> we all understand ring buffers and how awesome they are. &nbsp;Unfortunately for you, I have not said anything about how to actually populate them or read from them when you're using the Disruptor.<br /><br /><b>ConsumerBarriers and Consumers</b><br />I'm going to approach this slightly backwards, because it's probably easier to understand in the long run. &nbsp;Assuming that some magic has populated it: how do you read something from the ring buffer? <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-XfVLYjAqNeY/TgjrImkZ-BI/AAAAAAAAIEg/_SM2EqIgATs/s1600/ConsumerWaitFor.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em; text-align: center;"><img border="0" height="214" src="http://1.bp.blogspot.com/-XfVLYjAqNeY/TgjrImkZ-BI/AAAAAAAAIEg/_SM2EqIgATs/s640/ConsumerWaitFor.png" width="640" /></a></div><br />(OK, I'm starting to regret using Paint/<a href="http://www.gimp.org/">Gimp</a>. &nbsp;Although it's an excellent excuse to purchase a graphics tablet if I do continue down this road. &nbsp;Also UML gurus are probably cursing my name right now.)<br /><br />Your <code>Consumer</code> is the thread that wants to get something off the buffer. &nbsp;It has access to a <code>ConsumerBarrier</code>, which is created by the <code>RingBuffer</code> and interacts with it on behalf of the <code>Consumer</code>. &nbsp;While the ring buffer obviously needs a sequence number to figure out what the next available slot is, the consumer also needs to know which sequence number it's up to - each consumer needs to be able to figure out which sequence number it's expecting to see next. &nbsp;So in the case above, the consumer has dealt with everything in the ring buffer up to and including 8, so it's expecting to see 9 next.<br /><br />The consumer calls <code>waitFor</code> on the <code>ConsumerBarrier</code> with the sequence number it wants next<br /><br /><pre><code style="font-size: 12px;">    final long availableSeq = consumerBarrier.waitFor(nextSequence);<br /></code></pre><br />and the <code>ConsumerBarrier</code> returns the highest sequence number available in the ring buffer - in the example above, 12. &nbsp;The <code>ConsumerBarrier</code> has a <code>WaitStrategy</code> which it uses to decide how to wait for this sequence number - I won't go into details of that right now, the code has comments in outlining the advantages and disadvantages of each.<br /><br /><b>Now what?</b><br />So the consumer has been hanging around waiting for more stuff to get written to the ring buffer, and it's been told what has been written - entries 9, 10, 11 and 12. &nbsp;Now they're there, the consumer can ask the <code>ConsumerBarrier</code> to fetch them.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-NKI4nQgA_Co/TgjsGRyaTWI/AAAAAAAAIEk/S7fAyNrjlXQ/s1600/ConsumerRequest.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="222" src="http://2.bp.blogspot.com/-NKI4nQgA_Co/TgjsGRyaTWI/AAAAAAAAIEk/S7fAyNrjlXQ/s640/ConsumerRequest.png" width="640" /></a></div><br />As it's fetching them, the <code>Consumer</code> is updating its own cursor. <br /><br />You should start to get a feel for how this helps to smooth latency spikes - instead of asking "Can I have the next one yet? &nbsp;How about now? &nbsp;Now?" for every individual item, the <code>Consumer</code> simply says "Let me know when you've got more than this number", and is told in return how many more entries it can grab. &nbsp;Because these new entries have definitely been written (the ring buffer's sequence has been updated), and because the only things trying to get to these entries can only read them and not write to them, this can be done without locks. &nbsp;Which is nice. &nbsp;Not only is it safer and easier to code against, it's much faster not to use a lock.<br /><br />And the added bonus - you can have multiple <code>Consumers</code> reading off the same <code>RingBuffer</code>, with no need for locks and no need for additional queues to coordinate between the different threads. &nbsp;So you can really run your processing in parallel with the Disruptor coordinating the effort.<br /><br />The <a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchConsumer.java">BatchConsumer</a> is an example of consumer code, and if you implement the <a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchHandler.java">BatchHandler </a>you can get the <code>BatchConsumer</code> to do the heavy lifting I've outlined above. &nbsp;Then it's easy to deal with the whole batch of entries processed (e.g. from 9-12 above) without having to fetch each one individually.<br /><br />EDIT: Note that version 2.0 of the Disruptor uses different names to the ones in this article. &nbsp;Please see&nbsp;<a href="http://mechanitis.blogspot.com/2011/08/disruptor-20-all-change-please.html">my summary of the changes</a>&nbsp;if you are confused about class names.
