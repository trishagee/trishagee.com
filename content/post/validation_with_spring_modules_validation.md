{
 "disqus_url" : "http://trishagee.github.io/post/validation_with_spring_modules_validation/",
 "disqus_title" : "Validation with Spring Modules Validation",
 "Title": "Validation with Spring Modules Validation",
 "Pubdate": "2007-07-16",
 "Keywords": ["spring", "code"],
 "Tags": ["spring", "code"],
 "Slug": "validation_with_spring_modules_validation",
 "Section": "post"
}
So if java generics slightly <a href="http://mechanitis.livejournal.com/6783.html">disappointed me lately</a>, what have I found cool?<br/><br/>I'm currently working on a web application using <a href="http://www.springframework.org/docs/reference/mvc.html">Spring MVC</a>, which probably doesn't come as a big surprise, it seems to be all the rage these days.  Since this is my baby, I got to call the shots as to a lot of the framework choices.  When it came to looking at implementing validation, I refused to believe I'd have to go through the primitive process of looking at all the values on the request and deciding if they pass muster, with some huge <code>if</code> statement.  Even with Spring's rather marvelous <a href="http://static.springframework.org/spring/docs/2.0.x/reference/validation.html">binding and validation mechanisms</a> to take the worst of the tasks off you, it still looked like it would be a bit of a chore.  Given all the cool things you can do with AOP etc I figured someone somewhere must've implemented an annotations-based validation plugin for Spring.<br/><br/><a href="https://springmodules.dev.java.net/docs/reference/0.8/html_single/#validation">And they have</a>.  And there's actually a reasonable amount of information about how to set it up and get it working.  The problem is that it's pretty flexible and has a lot of different options, so when you are running Java 1.5 and Spring 2.0, and actually want to use the validation in a simple, straightfoward fashion, the setup instructions get lost.<br/><br/>So here's my record so I don't forget in future how I did it.<br/><br/>As a brief summary for those who may not be familiar with Spring, or for those who need reminding (no doubt me in a few months when I've completely forgetten what I was working on), Spring provides a <code>Validator</code> interface that you can use to easily plug validation into your application.  In the context of web applications, you create your various <code>Validators</code> and in your application context XML file you tell your Controllers to use those validators on form submission (for example).<br/><br/>Spring Modules validation provides a bunch of generic validation out of the box for all the tedious, standard stuff - length validation, mandatory fields, valid e-mail addresses etc (<a href="https://springmodules.dev.java.net/docs/reference/0.8/html_single/#d0e8935">details here</a>).  And you can plug this straight into your application by using annotations.  How?  Easy.<br/><br/>This is my outline application context file:<br/><pre><br/>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br/>&lt;beans xmlns=&quot; http://www.springframework.org/schema/beans&quot;<br/>	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance &quot;<br/>	xmlns:vld=&quot;http://www.springmodules.org/validation/bean/validator &quot;<br/>	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd<br/>						http://www.springmodules.org/validation/bean/validator http://www.springmodules.org/validation/bean/validator.xsd&quot;&gt;<br/><br/>	&lt;vld:annotation-based-validator id=&quot;validator&quot; /&gt;<br/><br/>	&lt;!-- Load messages --&gt;<br/>	&lt;bean id=&quot;messageSource&quot;<br/>		class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;<br/>		&lt;property name=&quot;basenames&quot; value=&quot;messages,errors&quot; /&gt;<br/>	&lt;/bean&gt;<br/><br/>	&lt;!-- Bean initialisation for validation. You can put these explicitly into your controllers or set to autowire by name or type --&gt;<br/>	&lt;bean id=&quot;messageCodesResolver&quot;<br/>		class=&quot;org.springmodules.validation.bean.converter.ModelAwareMessageCodesResolver&quot; /&gt;<br/><br/>&lt;/beans&gt;<br/></pre><br/>Really all you're interested in is the addition of the validation namespace and schema at the top of the file, and the <code>&lt;vld:annotation-based-validator id=&quot;validator&quot; /&gt;</code> line which is your actual validator.  The other sections are a message source so your error codes can have meaningful messages and a MessageCodeResolver to make use of these.<br/><br/>Eclipse does seem to moan about the way the springmodules schema is referenced, but when you actually start Tomcat up it seems happy enough.<br/><br/>I've chosen to give the validator the ID <code>validator</code> because I turned autowire by name on so that all my controllers picked up this validation by default.  Note: autowire can be a little bit dangerous and I've actually turned it off now because I had a <code>validator</code> bean and a <code>validators</code> list in the context file and my poor SimpleFormController controllers were getting a bit confused over which one to use (in truth, the single validator was overwriting the list, which was not what I was after at all).<br/><br/>Anyway.  Now what?  We have a validator and we've probably wired it into the relevant controllers, either by autowiring them or poking it specifically into our controllers like this:<br/><pre><br/>	&lt;bean id=&quot;somePersonController&quot;<br/>		class=&quot;com.mechanitis.examples.validation.controller.MyPersonController&quot;&gt;<br/>		&lt;property name=&quot;commandClass&quot;<br/>			value=&quot;com.mechanitis.examples.validation.command.PersonCommand&quot; /&gt;<br/>		&lt;property name=&quot;formView&quot; value=&quot;person&quot; /&gt;<br/>		&lt;property name=&quot;successView&quot; value=&quot;success&quot; /&gt;<br/>		&lt;property name=&quot;validator&quot; ref=&quot;validator&quot;/&gt;<br/>	&lt;/bean&gt;<br/></pre><br/>Next step is to add some validation rules.  <a href="https://springmodules.dev.java.net/docs/reference/0.8/html_single/#d0e8930">The documentation</a> will show you how to do this using an XML file, which you're perfectly welcome to do.  However what I wanted to show is how to use annotations on your command object to declare your validation.  So here you are:<br/><br/><pre><br/>import org.springmodules.validation.bean.conf.loader.annotation.handler.CascadeValidation;<br/>import org.springmodules.validation.bean.conf.loader.annotation.handler.Email;<br/>import org.springmodules.validation.bean.conf.loader.annotation.handler.Length;<br/>import org.springmodules.validation.bean.conf.loader.annotation.handler.Min;<br/>import org.springmodules.validation.bean.conf.loader.annotation.handler.NotNull;<br/><br/>public class PersonCommand {<br/>    private static final int NAME_MAX_LENGTH = 50;<br/><br/>    @NotNull<br/>    @Length(min = 1, max = NAME_MAX_LENGTH)<br/>    private String name;<br/><br/>    @Min(value=1)<br/>    private Long age;<br/>    <br/>    @Email<br/>    private String eMail;<br/><br/>    @CascadeValidation<br/>    private RelationshipCommand relationship = new RelationshipCommand();<br/><br/>    private String action;<br/><br/>    //insert getters and setters etc<br/><br/>}<br/></pre><br/>Note that <code>@CascadeValidation</code> tells the validator to run validation on the enclosed secondary Command.<br/><br/>This is just a simple example obviously.  But hopefully you can see that now you've got the validator set up correctly in your application context file, all you need to cover 90% of your validation needs is to tag the relevant fields with the type of validation you want.  If you want to get really clever, the validator supports <a href="https://springmodules.dev.java.net/docs/reference/0.8/html_single/#valang">Valang</a> which allows you to write simple rules.  For example, if I only want to validate the name when I'm saving the person rather than passing the command around for some other purpose, I might change the annotations on the name field:<br/><br/><pre><br/>    @NotNull(applyIf="action EQUALS 'savePerson'")<br/>    @Length(min = 1, max = NAME_MAX_LENGTH, applyIf="action EQUALS 'savePerson'")<br/>    private String name;<br/></pre><br/>That's the basics.  Before I let you go off and play though, a word about error messages.  As usual with Spring validators, you can specify pretty messages to be displayed to the user when things go wrong.  In my application context file above you should see that I've specified a properties file called errors.  In this file you can map your error codes to the message to display.  When using the spring modules validation I found the error codes generated were like the ones below so you might have an errors.properties file that looks like this:<br/><br/><pre><br/># *** Errors for the Person screens<br/>PersonCommand.age[min]=An age should be entered<br/>PersonCommand.name[length]=Person name should be between 1 and 50 characters<br/># etc etc<br/><br/># *** General errors<br/>not.null=This field cannot be empty<br/></pre><br/><br/>Go play.
