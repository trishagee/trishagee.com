{
 "disqus_url" : "http://trishagee.github.io/post/spock_is_awesome_seriously_simplified_mocking/",
 "disqus_title" : "Spock is awesome! Seriously Simplified Mocking",
 "Title": "Spock is awesome! Seriously Simplified Mocking",
 "Pubdate": "2013-07-09",
 "Slug": "spock_is_awesome_seriously_simplified_mocking",
 "Section": "post"
}
We're constantly fighting a battle when developing the new MongoDB Java driver between using tools that will do heavy lifting for us and minimising the dependencies a user has to download in order to use our driver. &nbsp;Ideally, we want the number of dependencies to be zero.<br /><br />This is not going to be the case when it comes to testing, however. &nbsp;At the very least, we're going to use JUnit or TestNG (we used testng in the previous version, we've switched to JUnit for 3.0). &nbsp;Up until recently, we worked hard to eliminate the need for a mocking framework - the driver is not a large application with interacting services, most stuff can be tested either as an integration test or with very simple stubs.<br /><br />Recently I was working on the serialisation layer - we're making quite big changes to the model for encoding and decoding between <a href="http://bsonspec.org/">BSON</a> and Java, we're hoping this will simplify our lives but also make things a lot easier for the ODMs (Object-Document Mappers) and third party libraries. &nbsp;At this level, it makes a lot of sense to introduce mocks - I want to ensure particular methods are called on the writer, for example, I don't want to check actual byte values, that's not going to be very helpful for documentation (although there is a level where that is a sensible thing to do).<br /><br />We started using <a href="http://jmock.codehaus.org/">JMock</a> to begin with, it's what I've been using for a while, and it gave us what we wanted - a simple mocking framework (I tried <a href="https://code.google.com/p/mockito/">Mockito</a> too, but I'm not so used to the failure messages, so I found it really hard to figure out what was wrong when a test failed). <br /><br />I knew from my spies at LMAX that there's some <a href="http://groovy.codehaus.org/">Groovy</a> test framework called <a href="https://code.google.com/p/spock/">Spock</a> that is awesome, apparently, but I&nbsp;immediately&nbsp;discarded it - I feel very strongly that tests are documentation, and since the users of the Java driver are largely Java developers, I felt like introducing tests in a different language was an added complexity we didn't need.<br /><br />Then I went to GeeCON, and my ex-colleague <a href="https://twitter.com/IsraKaos">Israel</a> forced me to go to <a href="http://geecon.org/speakers/ken-sipe">the talk on Spock</a>. &nbsp;And I realised just how wrong I had been. &nbsp;Far from adding complexity, here was a lovely, descriptive way of writing tests. &nbsp;It's flexible, and yet structured enough get you thinking in a way that should create good tests.<br /><br />Since we're already using <a href="http://www.gradle.org/">gradle</a>, which is Groovy as well, we decided it was worth a spike to see if Spock would give us any benefits.<br /><br />During the spike I converted a selection of our tests to Spock tests to see what it looks like on a <i>real</i> codebase. &nbsp;I had very specific things I wanted to try out:<br /><br /><ul><li>Mocking</li><li>Stubbing</li><li>Data driven testing</li></ul><br />In the talk I also saw useful annotation like&nbsp;<code>@Requires</code>, which I'm pretty sure we're going to use, but I don't think it's made it into a build yet.<br /><br />So, get this, I'm going to write a blog post with Actual Code in. &nbsp;Yeah, I know, you all thought I was just a poncy evangelist these days and didn't do any real coding any more.<br /><br /><b>First up, Mocking</b><br />So, as I said, I have a number of tests checking that encoding of Java objects works the way we expect. &nbsp; The easiest way to test this is to mock our <a href="https://github.com/mongodb/mongo-java-driver/blob/3.0.x/bson/src/main/org/bson/BSONWriter.java">BSONWriter</a> class to ensure that the right interactions are happening against it. &nbsp;This is a nice way to check that when you give an encoder a particular set of data, it gets serialised in the way BSON expects. These tests ended up looking something like this:<br /><div><br /><script src="https://gist.github.com/trishagee/5728846.js"></script></div>(Yeah, I'm still learning Spanish).<br /><br />So that's quite nice, my test checks that given a List of Strings, they get serialised correctly. &nbsp;What's not great is some of the setup overhead:<br /><br /><script src="https://gist.github.com/trishagee/5728883.js"></script>Obviously some of the things there are going to be ringing some people's alarm bells, but let's assume for a minute that all decisions were taken carefully and that pros and cons were weighed accordingly.<br /><br />So:<br /><ul><li>Mocking concrete classes is not pretty in JMock, just look at that <code>setUp</code> method.</li><li>We're using the <code>JUnitRuleMockery</code>, which appears to be Best Practice (and means you're less likely to forget the&nbsp;<code>@RunWith(JMock.class)</code> annotation), but checkstyle hates it - Public Fields Are Bad as we all know.</li></ul>But it's fine, a small amount of boilerplate for all our tests that involve mocking is an OK price to pay to have some nice tests.<br /><br />I converted this test to a Spock test. &nbsp;Groovy purists will notice that it's still very Java-y, and that's intentional - I want these tests, at least at this stage while we're getting used to it, to be familiar to Java programmers, our main audience.<br /><br /><script src="https://gist.github.com/trishagee/5728962.js"></script> Some initial observations:<br /><ul><li>It's a really simple thing, but I like having the&nbsp;<code>@Subject</code> annotation on the thing you're testing. &nbsp;In theory it should be obvious which of your fields or variables is the subject under test, but in practice that's not always true.</li><li>Although it freaks me out as someone who's been doing Java for the last 15 years, I really like the String for method name - although in this case it's the same as the JMock/JUnit equivalent, it gives a lot more flexibility for describing the purpose of this test.</li></ul><ul><li>Mocking is painless, with a simple call to <code>Mock()</code>, even though we're still mocking concrete classes (this is done simply by adding <a href="http://cglib.sourceforge.net/">cglib</a> and <a href="https://code.google.com/p/objenesis/">obgenesis</a> to the dependencies).</li><li>I <i>love</i>&nbsp;that the phases of Spock (<code>setup: when: then:</code>) document the different parts of the test while also being the useful magic keywords which tell Spock how to run the test. &nbsp;I know other frameworks provide this, but we've been working with JUnit and I've been in the habit of commenting my steps with <code>//given //when //then</code>.</li><li>Thanks to Groovy, creation of lists is less boiler plate (line 9). &nbsp;Not a big deal, but just makes it easier to read.</li><li>I've got very used to the way expectations are set up in JMock, but I have to say that <code>1 * bsonWriter.blahblahblah()</code> is much more readable. &nbsp;</li><li>I love that everything after <code>then:</code> is an assertion, I think it makes it really clear what you expect to happen after you invoke the thing you're testing.</li></ul>So mocking is awesome. &nbsp;What's next?<br /><br /><ul><li><a href="http://mechanitis.blogspot.co.uk/2013/07/spock-passes-next-test-painless-stubbing.html">Painless Stubbing</a></li><li><a href="http://mechanitis.blogspot.com.es/2013/12/spock-data-driven-testing.html">Data Driven Testing</a></li></ul>
