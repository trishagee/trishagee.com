{
 "disqus_url" : "http://trishagee.github.io/post/overheard_agile_truths/",
 "disqus_title" : "Overheard: Agile truths",
 "Title": "Overheard: Agile truths",
 "Pubdate": "2012-04-20",
 "Keywords": ["opinion", "agile"],
 "Tags": ["opinion", "agile"],
 "Slug": "overheard_agile_truths",
 "Section": "post"
}
After attending a number of conferences and events, and performing numerous interviews, I'm starting to hear the same things again and again. &nbsp;Since <a href="http://twitter.com/#!/tastapod">Dan North</a> <a href="http://qconlondon.com/london-2012/presentation/Decisions,%20decisions">challenged all my assumptions at QCon</a>, I'm reluctant to outright ridicule them, but I will put forward my personal opinion.<br /><br />Note: these are things I have heard from multiple sources, so with any luck I am not breaking the sanctity of the <strike>confessional</strike> interview.<br /><br /><b>I've never pair programmed, but I've frequently worked with a partner on critical production problems</b><br />I find this fascinating. &nbsp;If there's one thing that needs to be fixed as fast, as correctly, as efficiently as possible, it's a production issue. &nbsp;And when there is one, "everyone" knows that two heads are better than one, even The Business.<br /><br />If this is the case, why is it so hard to sell pair programming as the default state of affairs?<br /><br />Is it because creating new features is seen as just typing, where the bottleneck is access to the physical keyboard? &nbsp;Is it because fixing defects when the pressure <i>isn't</i> on is suddenly easier for one person on their own without help?<br /><br />This state of affairs is interesting to me as it implies that when&nbsp;proverbial&nbsp;hits the fan, the instinctive thing to do is to work collaboratively. &nbsp;Why don't we do it more often?<br /><br /><b>We use Test Driven Development to get coverage</b><br />Seems weird to me to write your tests first to get coverage. &nbsp;If unit test coverage is your most important metric (and <a href="http://craftedsw.blogspot.co.uk/2012/02/code-coverage-is-side-effect-and-not.html">other</a> <a href="http://goodenoughsoftware.net/2012/03/21/code-coverage/">people</a> <a href="http://martinfowler.com/bliki/TestCoverage.html">have</a> covered why this might not be the case), I'm not sure why you would write your tests first. &nbsp;Seems to me that you'd get better coverage writing the tests <i>after</i> the code. &nbsp;That way you can be sure you've covered every eventuality.<br /><br />To me, the statement implies two assumptions which I would challenge:<br />a) The primary value of writing your tests first is to meet your coverage requirements<br />b) Coverage is a meaningful metric<br /><br />TDD/BDD has a number of benefits (...and now I'm reluctant to list them here in case people repeat them back to me in an interview). &nbsp;Good coverage will probably be a side effect of being forced to write your tests first, but I'm not convinced that's the best thing that will come out of using TDD.<br /><br /><b>I only test first when I know what I want to code</b><br />I've overheard people saying that they test first when they know what the code is going to look like. &nbsp;So you dive straight into the code when you <i>don't</i> know what you're doing???<br /><br />Of course there is a place for this - spikes, prototyping, getting a feel for a new library, so on and so forth. &nbsp;But I feel that for most code that you write in your day job, you probably have a business requirement and possibly (probably?) a less firm idea of how you're going to code it. &nbsp;To me, this translates into writing the test first (which documents what you want to deliver, which you already know) and then getting that to pass (which is writing the code, which is the bit you might not know). <br /><br />If you know exactly what the code is going to look like a) I would question that statement and b) what's the point of the test?<br /><br /><br /><b>What are the real answers?</b><br />At <a href="http://mechanitis.blogspot.co.uk/2012/03/qcon-london-2012.html">QCon</a> I saw on Twitter a number of complaints because the presentations there gave opinions, guidelines, and, worst of all, a lot of "it depends". &nbsp;But people seemed to want The Answers.<br /><br />In my opinion, what developers get paid for is working out the "it depends" parameters and selecting an approach, technical or process-wise, that works for their situation.<br /><br />So although I have strong opinions on all the above subjects, and although LMAX has specific approaches to both pair programming and automated testing, sadly I'm not going to go into lots of details about those.<br /><br />Mostly because I'm still interviewing candidates, and I don't want to give away the correct answers....
