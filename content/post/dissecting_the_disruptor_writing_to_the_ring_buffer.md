{
 "disqus_url" : "http://trishagee.github.io/post/dissecting_the_disruptor_writing_to_the_ring_buffer/",
 "disqus_title" : "Dissecting the Disruptor: Writing to the ring buffer",
 "Title": "Dissecting the Disruptor: Writing to the ring buffer",
 "Pubdate": "2011-07-04",
 "Keywords": ["java", "disruptor", "lmax", "disruptor-docs", "concurrency"],
 "Tags": ["java", "disruptor", "lmax", "disruptor-docs", "concurrency"],
 "Slug": "dissecting_the_disruptor_writing_to_the_ring_buffer",
 "Section": "post"
}
<div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">This is the missing piece in the end-to-end view of the Disruptor. &nbsp;Brace yourselves, it's quite long. &nbsp;But I decided to keep it in a single blog so you could have the context in one place.<br /><br />The important areas are: not wrapping the ring; informing the consumers; batching for producers; and how multiple producers work.<br /><br /><b>ProducerBarriers</b><br />The <a href="http://code.google.com/p/disruptor/">Disruptor code</a> has interfaces and helper classes for the <code>Consumer</code>s, but there's no interface for your producer, the thing that writes to the ring buffer. &nbsp;That's because nothing else needs to access your producer, only you need to know about it. &nbsp;However, like the consuming side, a <code>ProducerBarrier</code> is created by the ring buffer and your producer will use this to write to it.<br /><br />Writing to the ring buffer involves a two-phase commit. &nbsp;First, your producer has to claim the next slot on the buffer. &nbsp;Then, when the producer has finished writing to the slot, it will call <code>commit</code> on the <code>ProducerBarrier</code>.<br /><br />So let's look at the first bit. &nbsp;It sounds easy - "get me the next slot on the ring buffer". &nbsp;Well, from your producer's point of view it is easy. &nbsp;You simply call <code>nextEntry()</code> on the <code>ProducerBarrier</code>. &nbsp;This will return you an <code>Entry</code> object which is basically the next slot in the ring buffer.<br /><br /><b>The ProducerBarrier makes sure the ring buffer doesn't wrap</b><br />Under the covers, the <code>ProducerBarrier</code> is doing all the negotiation to figure out what the next slot is, and if you're allowed to write to it yet.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-YOp3ahmnRLw/ThCPQmuS2gI/AAAAAAAAIE0/oI-w-1l2RJc/s1600/PreventRingFromWrapping.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="231" src="http://3.bp.blogspot.com/-YOp3ahmnRLw/ThCPQmuS2gI/AAAAAAAAIE0/oI-w-1l2RJc/s640/PreventRingFromWrapping.png" width="640" /></a></div><br />(I'm not convinced the <a href="http://www.amazon.com/Wacom-CTL460-Bamboo-Pen-Tablet/dp/B002OOWC3I?ie=UTF8&amp;tag=trissramb-20&amp;link_code=btl&amp;camp=213689&amp;creative=392969" target="_blank">shiny new graphics tablet</a><img alt="" border="0" height="1" src="http://www.assoc-amazon.com/e/ir?t=trissramb-20&amp;l=btl&amp;camp=213689&amp;creative=392969&amp;o=1&amp;a=B002OOWC3I" style="border: none !important; margin: 0px !important; padding: 0px !important;" width="1" /> is helping the clarity of my pictures, but it's  fun to use).<br /><br />For this illustration, we're going to assume there's only one producer writing to the ring buffer. &nbsp;We will deal with the intricacies of multiple producers later.<br /><br />The <code>ConsumerTrackingProducerBarrier</code> has a list of all the <code>Consumers</code> that are accessing the ring buffer. &nbsp;Now to me this seemed a bit odd - I wouldn't expect the <code>ProducerBarrier</code> to know anything about the consuming side.  But wait, there is a reason. &nbsp;Because we don't want the "conflation of concerns" a queue has (it has to track the head and tail which are sometimes the same point), our consumers are responsible for knowing which sequence number they're up to, not the ring buffer. &nbsp;So, if we want to make sure we don't wrap the buffer, we need to check where the consumers have got to.<br /><br />In the diagram above, one <code>Consumer</code> is happily at the same point as the highest sequence number (12, highlighted in red/pink). The second <code>Consumer</code> is a bit behind - maybe it's doing I/O operations or something - and it's at sequence number 3. &nbsp;Therefore consumer 2 has the whole length of the buffer to go before it catches up with consumer 1.<br /><br />The producer wants to write to the slot on the ring buffer currently occupied by sequence 3, because this slot is the one after the current ring buffer cursor. &nbsp;But the <code>ProducerBarrier</code> knows it can't write here because a <code>Consumer</code> is using it. &nbsp;So the <code>ProducerBarrier</code> sits and spins, waiting, until the consumers move on.<br /><br /><b>Claiming the next slot</b><br />Now imagine consumer 2 has finished that batch of entries, and moves its sequence number on. Maybe it got as far as sequence 9 (in real life I expect it will make it as far as 12 because of the way consumer batching works, but that doesn't make the example as interesting).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-IxEJ_Dy6_RU/ThCVQIwgLoI/AAAAAAAAIE4/-z4AsZD5nVg/s1600/ProducerNextEntry.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="236" src="http://4.bp.blogspot.com/-IxEJ_Dy6_RU/ThCVQIwgLoI/AAAAAAAAIE4/-z4AsZD5nVg/s640/ProducerNextEntry.png" width="640" /></a></div><br />The diagram above shows what happens when consumer 2 updates to sequence number 9. &nbsp;I've slimmed down the <code>ConsumerBarrier</code> in this picture because it takes no active part in this scene.<br /><br />The <code>ProducerBarrier</code> sees that the next slot, the one that had sequence number 3, is now available. &nbsp;It grabs the <code>Entry</code> that sits in this slot (I've not talked specifically about the <code>Entry</code> class, but it's basically a bucket for stuff you want to put into the ring buffer slot which has a sequence number), sets the sequence number on the <code>Entry</code> to the next sequence number (13) and returns this entry to your producer. &nbsp;The producer can then write whatever value it wants into this <code>Entry</code>.<br /><br /><b>Committing the new value</b><br />The second phase of the two-stage commit is, well, the commit.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-vBm6k86SO4k/ThCm5GgkhEI/AAAAAAAAIFA/dB-9NNz47qw/s1600/ProducerCommit.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="224" src="http://2.bp.blogspot.com/-vBm6k86SO4k/ThCm5GgkhEI/AAAAAAAAIFA/dB-9NNz47qw/s640/ProducerCommit.png" width="640" /></a></div><br />The green represents our newly updated <code>Entry</code> with sequence 13 - yeah, I'm sorry, I'm red-green colour-blind too. &nbsp;But other colours were even more rubbish.<br /><br />When the producer has finished writing stuff into the entry it tells the <code>ProducerBarrier</code> to commit it.<br /><br />The <code>ProducerBarrier</code> waits for the ring buffer cursor to catch up to where we are (for a single producer this will always be a bit pointless - e.g. we know the cursor is already at 12, nothing else is writing to the ring buffer). &nbsp;Then the <code>ProducerBarrier</code> updates the ring buffer cursor to the sequence number on the updated <code>Entry</code> - 13 in our case. &nbsp;Next, the <code>ProducerBarrier</code> lets the consumers know there's something new in the buffer. &nbsp;It does this by poking the <code>WaitStrategy</code> on the <code>ConsumerBarrier</code> - "Oi, wake up! Something happened!" (note - different <code>WaitStrategy</code> implementations deal with this in different ways, depending upon whether it's blocking or not).<br /><br />Now consumer 1 can get entry 13, consumer 2 can get everything up to and including 13, and they all live happily ever after.<br /><br /><b>ProducerBarrier batching</b><br />Interestingly the disruptor can batch on the producer side as well as <a href="http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-how-do-i-read-from.html">on the Consumer side</a>. &nbsp;Remember when consumer 2 finally got with the programme and found itself at sequence 9? &nbsp;There is a very cunning thing the <code>ProducerBarrier</code> can do here - it knows the size of the buffer, and it knows where the slowest <code>Consumer</code> is. &nbsp;So it can figure out which slots are now available.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-781DHcbmG2g/ThCXT2xo0xI/AAAAAAAAIE8/5Gls4znj3zw/s1600/ProducerBatching.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="236" src="http://4.bp.blogspot.com/-781DHcbmG2g/ThCXT2xo0xI/AAAAAAAAIE8/5Gls4znj3zw/s640/ProducerBatching.png" width="640" /></a></div><br />If the <code>ProducerBarrier</code> knows the ring buffer cursor is at 12, and the slowest <code>Consumer</code> is at 9, it can let producers write to slots 3, 4, 5, 6, 7 and 8 before it needs to check where the consumers are.<br /><br /><b>Multiple producers</b><br />You thought I was done, but there's more.<br /><br />I slightly lied in some of the above drawings. &nbsp;I implied that the sequence number the <code>ProducerBarrier</code> deals with comes directly from the ring buffer's cursor. &nbsp;However, if you look at the code you'll see that it uses the <code>ClaimStrategy</code> to get this. &nbsp;I skipped this to simplify the diagrams, it's not so important in the single-producer case.<br /><br />With multiple producers, you need yet another thing tracking a sequence number. &nbsp;This is the sequence that is available for writing to. &nbsp;Note that this is not the same as ring-buffer-cursor-plus-one - if you have more than one producer writing to the buffer, it's possible there are entries in the process of being written that haven't been committed yet.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-xPQJAkN7lgg/ThC8FGgosdI/AAAAAAAAIFE/qZO9xuiKFPY/s1600/ProducersNextEntry.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="274" src="http://4.bp.blogspot.com/-xPQJAkN7lgg/ThC8FGgosdI/AAAAAAAAIFE/qZO9xuiKFPY/s640/ProducersNextEntry.png" width="640" /></a></div><br />Let's revisit claiming a slot. &nbsp;Each producer asks the <code>ClaimStrategy</code> for the next available slot. &nbsp;Producer 1 gets sequence 13, like in the single producer case above. &nbsp;Producer 2 gets sequence 14, even though the ring buffer cursor is still only pointing to 12, because the <code>ClaimSequence</code> is dishing out the numbers and has been keeping track of what's been allocated.<br /><br />So each producer has its own slot with a shiny new sequence number.<br /><br />I'm going colour producer 1 and its slot in green, and producer 2 and its slot in a suspiciously pink-looking purple.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-4bSeLcewe-Q/ThDCM1rWOyI/AAAAAAAAIFQ/cF_dPHKNm-I/s1600/ProducersCommit.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-4bSeLcewe-Q/ThDCM1rWOyI/AAAAAAAAIFQ/cF_dPHKNm-I/s1600/ProducersCommit.png" /></a></div><br /><div class="separator" style="clear: both; text-align: -webkit-auto;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Now imaging producer 1 is away with the fairies, and hasn't got around to committing for whatever reason. &nbsp;Producer 2 is ready to commit, and asks the <code>ProducerBarrier</code> to do so.</div><div><br /></div><div>As we saw in the earlier commit diagram, the <code>ProducerBarrier</code> is only going to commit when the ring buffer cursor reaches the slot behind the one it wants to commit into. &nbsp;In this case, the cursor needs to reach 13 so that we can commit 14. &nbsp;But we can't, because producer 1 is staring at something shiny and hasn't committed yet. &nbsp;So the <code>ClaimStrategy</code> sits there spinning until the ring buffer cursor gets to where it should be.</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-2kzqD61cJNU/ThDEYBSFOkI/AAAAAAAAIFU/WY0m9sn5y-w/s1600/ProducersCommit2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="204" src="http://4.bp.blogspot.com/-2kzqD61cJNU/ThDEYBSFOkI/AAAAAAAAIFU/WY0m9sn5y-w/s640/ProducersCommit2.png" width="640" /></a></div><br />Now producer 1 wakes up from its coma and asks to commit entry 13 (green arrows are sparked by the request from producer 1). &nbsp;The <code>ProducerBarrier</code> tells the <code>ClaimStrategy</code> to wait for the ring buffer cursor to get to 12, which it already had of course. &nbsp;So the ring buffer cursor is incremented to 13, and the <code>ProducerBarrier</code> pokes the <code>WaitStrategy</code> to let everything know the ring buffer was updated. &nbsp;Now the <code>ProducerBarrier</code> can finish the request from producer 2, increment the ring buffer cursor to 14, and let everyone know that we're done.<br /><br />You'll see that the ring buffer retains the ordering implied by the order of the initial <code>nextEntry()</code> calls, even if the producers finish writing at different times. &nbsp;It also means that if a producer is causing a pause in writing to the ring buffer, when it unblocks any other pending commits can happen immediately.<br /><br />Phew. &nbsp;And I managed to describe all that without mentioning a memory barrier once.<br /><br /><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">EDIT: The most recent version of the&nbsp;<a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/RingBuffer.java?r=239">RingBuffer</a>&nbsp;hides away the Producer Barrier. &nbsp;If you can't see a&nbsp;<a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/ProducerBarrier.java?r=239">ProducerBarrier</a>&nbsp;in the code you're looking at, then assume where I say "producer barrier" I mean "ring buffer"<br /><br />EDIT 2: Note that version 2.0 of the Disruptor uses different names to the ones in this article. &nbsp;Please see&nbsp;<a href="http://mechanitis.blogspot.com/2011/08/disruptor-20-all-change-please.html">my summary of the changes</a>&nbsp;if you are confused about class names.</div></div>
