{
 "disqus_url" : "http://trishagee.github.io/post/dissecting_the_disruptor_wiring_up_the_dependencies/",
 "disqus_title" : "Dissecting the Disruptor: Wiring up the dependencies",
 "Title": "Dissecting the Disruptor: Wiring up the dependencies",
 "Pubdate": "2011-07-10",
 "Keywords": ["java", "disruptor", "lmax", "disruptor-docs", "concurrency"],
 "Tags": ["java", "disruptor", "lmax", "disruptor-docs", "concurrency"],
 "Slug": "dissecting_the_disruptor_wiring_up_the_dependencies",
 "Section": "post"
}
So now I've covered the <a href="http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-whats-so-special.html">ring buffer</a> itself, <a href="http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-how-do-i-read-from.html">reading</a> from it and <a href="http://mechanitis.blogspot.com/2011/07/dissecting-disruptor-writing-to-ring.html">writing</a> to it.<br /><br />Logically the next thing to do is to wire everything up together.<br /><br />I talked about multiple producers - they have the producer barrier to keep them in order and under control. &nbsp;I've talked about consumers in a simple situation. &nbsp;Multiple consumers can get a little more involved. &nbsp;<a href="http://www.lmaxtrader.co.uk/">We've</a> done some clever stuff to allow the consumers to be dependent on each other and the ring buffer. &nbsp;Like a lot of applications, we have a pipeline of things that need to happen before we can actually get on with the business logic - for example, we need to make sure the messages have been journalled to disk before we can do anything.<br /><br />The <a href="http://disruptor.googlecode.com/files/Disruptor-1.0.pdf">Disruptor paper</a> and the performance tests cover some basic configurations that you might want. I'm going to go over the most interesting one, mostly because I needed the practice with the graphics tablet.<br /><br /><b>Diamond configuration</b><br /><a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/perf/com/lmax/disruptor/DiamondPath1P3CPerfTest.java">DiamondPath1P3CPerfTest</a> illustrates a configuration which is not too uncommon - a single producer with three consumers. &nbsp;The tricky point being that the third consumer is dependent upon the previous two consumers to finish before it can do anything.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-34LTXhqK1wA/ThSvXbNTAjI/AAAAAAAAIFY/qpFZNXWgbPE/s1600/1P3C-Diamond.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="264" src="http://4.bp.blogspot.com/-34LTXhqK1wA/ThSvXbNTAjI/AAAAAAAAIFY/qpFZNXWgbPE/s400/1P3C-Diamond.png" width="400" /></a></div><br />Consumer three might be your business logic, consumer one could be backing up the data received, and consumer two may be preparing the data or something.<br /><br /><b>Diamond configuration using queues</b><br />In a <a href="http://www.theserverside.com/news/1363672/Building-a-Scalable-Enterprise-Applications-Using-Asynchronous-IO-and-SEDA-Model">SEDA-style architecture</a>, each stage will be separated by a queue:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-4Di1CzgcZR0/ThSzSdp1sTI/AAAAAAAAIFc/9mhK_7hLBdk/s1600/1P3C-Diamond-Queue.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="263" src="http://1.bp.blogspot.com/-4Di1CzgcZR0/ThSzSdp1sTI/AAAAAAAAIFc/9mhK_7hLBdk/s400/1P3C-Diamond-Queue.png" width="400" /></a></div><br />(Why does queue have to have so many "e"s? &nbsp;It's the letter I have the most trouble with in these drawings).<br /><br />You might get an inkling of the problem here: for a message to get from P1 to C3 it has to travel through four whole queues, each queue taking its cost in terms of putting the message on the queue and taking it off again.<br /><br /><b>Diamond configuration using the Disruptor</b><br />In the <a href="http://code.google.com/p/disruptor/">Disruptor</a> world, it's all managed on a single ring buffer:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-fGp-zkgVWs0/ThnC8m1O8bI/AAAAAAAAIHI/jUZJ6Xos608/s1600/1P3C-Diamond-RingBuffer.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="359" src="http://1.bp.blogspot.com/-fGp-zkgVWs0/ThnC8m1O8bI/AAAAAAAAIHI/jUZJ6Xos608/s640/1P3C-Diamond-RingBuffer.png" width="640" /></a></div>It does look more complicated. &nbsp;But the ring buffer remains the single point of contact between all the players, and the interactions are all based on the barriers checking the sequence numbers of the things it's dependent upon.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div>The producer side is fairly simple, it's the single producer model described in my <a href="http://mechanitis.blogspot.com/2011/07/dissecting-disruptor-writing-to-ring.html">last post</a>. Interestingly, the producer barrier doesn't have to care about all the consumers. &nbsp;It only cares about consumer three, because if consumer three has finished with an item in the ring buffer the other two will already have processed it. &nbsp;So if C3 has moved on, that slot in the ring buffer is available.<br /><br />To manage the dependencies between the consumers you need two consumer barriers. &nbsp;The first just talks to the ring buffer and consumers one and two ask it for the next available item. &nbsp;The second consumer barrier knows about consumers one and two, and it will return the lowest sequence number processed by both consumers.<br /><br /><b>How consumer dependencies work in the Disruptor</b><br />Hmm. &nbsp;I can see I'm going to need an example.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-CDUq8tbkg5U/ThTBcrHD_wI/AAAAAAAAIFo/edukW6dAG5Q/s1600/1P3C-Diamond-RingBuffer-Example.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="294" src="http://3.bp.blogspot.com/-CDUq8tbkg5U/ThTBcrHD_wI/AAAAAAAAIFo/edukW6dAG5Q/s640/1P3C-Diamond-RingBuffer-Example.png" width="640" /></a></div>We're joining the party halfway through the story: the producer has filled the ring buffer up to sequence number 22; consumer one has read and processed everything up to 21; consumer two has processed everything up to sequence 18; consumer three, which is dependent upon the other consumers, has only made it as far as 15.<br /><br />The producer can't write anything more to the ring buffer because sequence 15 is taking up the slot where we'd want to put sequence 23.<br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-PKLturGyJac/ThnEt30SVLI/AAAAAAAAIHM/8w-q90sErcY/s1600/1P3C-Diamond-RingBuffer-Example2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="314" src="http://3.bp.blogspot.com/-PKLturGyJac/ThnEt30SVLI/AAAAAAAAIHM/8w-q90sErcY/s640/1P3C-Diamond-RingBuffer-Example2.png" width="640" /></a></div>(I'm sorry, I really did try to find an alternative to red and green, but everything else was just as ambiguous).<br /><br />The first consumer barrier lets consumers one and two know they can grab anything up to sequence 22, the highest sequence number in the ring buffer. &nbsp;The second consumer barrier checks the ring buffer sequence, but it also checks the sequences on the other two consumers and returns the lowest value. &nbsp;So consumer three is told it can get anything up to sequence 18 from the ring buffer.<br /><br />Note that the consumers are still reading the entries directly from the ring buffer - consumers one and two are not taking the entries off the ring buffer and then passing them on to consumer three. &nbsp;Instead, the second consumer barrier is letting consumer three know which entry in the ring buffer it's safe to process.<br /><br />This raises a question - if everything comes directly off the ring buffer, how is consumer three going to find out about anything the first two consumers have done? &nbsp;If all consumer three cares about is that the earlier consumers have done their job (e.g. replicating the data to somewhere else) then everything's fine - when consumer three is told the job is done, it's happy. &nbsp;If, however, consumer three needs the results of an earlier consumer's processing, where does it get that from?<br /><br /><b>Modifying entries</b><br />The secret is to write them to the ring buffer&nbsp;<code>Entry</code> itself. &nbsp;This way, when consumer three grabs the entry off the ring buffer, it will have been populated with all the information consumer three needs to do the job. &nbsp;The really important part of this is that for each field on the <code>Entry</code>&nbsp;only one consumer is allowed to write to it. &nbsp;This prevents any write-contention which will slow the whole thing down.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-C26vt5NZaFo/ThnI4LpUzdI/AAAAAAAAIHU/I_9vAzu8EQY/s1600/FizzBuzzEntry.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="215" src="http://3.bp.blogspot.com/-C26vt5NZaFo/ThnI4LpUzdI/AAAAAAAAIHU/I_9vAzu8EQY/s400/FizzBuzzEntry.png" width="400" /></a></div><br />You can see this in <a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/perf/com/lmax/disruptor/DiamondPath1P3CPerfTest.java">DiamondPath1P3CPerfTest</a> - <a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/perf/com/lmax/disruptor/support/FizzBuzzEntry.java">FizzBuzzEntry</a> has two fields as well as the value: <code>fizz</code> and <code>buzz</code>. &nbsp;If the consumer is a Fizz consumer, it writes to <code>fizz</code>. &nbsp;If it's a Buzz consumer, it writes to <code>buzz</code>. &nbsp;The third consumer, FizzBuzz, will read both of these fields but not write to either, since reading is fine and won't cause contention.<br /><br /><b>Some actual Java code</b><br />All this looks more complicated than the queue implementation. &nbsp;And yes, it does involve a bit more coordination. &nbsp;But this is hidden from the consumers and producers, they just talk to the barriers. &nbsp;The trick is in the configuration. &nbsp;The diamond graph in the example above would be created using something like the following:<br /><br /><pre>ConsumerBarrier consumerBarrier1 = ringBuffer.createConsumerBarrier();<br /><br />BatchConsumer consumer1 = new BatchConsumer(consumerBarrier1, handler1);<br />BatchConsumer consumer2 = new BatchConsumer(consumerBarrier1, handler2);<br /><br />ConsumerBarrier consumerBarrier2 = <br />    ringBuffer.createConsumerBarrier(consumer1, consumer2);<br /><br />BatchConsumer consumer3 = new BatchConsumer(consumerBarrier2, handler3);<br /><br />ProducerBarrier producerBarrier = <br />    ringBuffer.createProducerBarrier(consumer3);<br /></pre><br /><b>In summary</b><br />So there you have it - how to wire up the Disruptor with multiple consumers that are dependent on each other. &nbsp;The key points:<br /><div class="separator" style="clear: both; text-align: center;"></div><ul><li>Use multiple consumer barriers to manage dependencies between consumers.</li><li>Have the producer barrier watch the last consumer in the graph.</li><li>Allow only one consumer to write to an individual field in an <code>Entry</code>.</li></ul>EDIT: Adrian has <a href="http://www.symphonious.net/2011/07/11/lmax-disruptor-high-performance-low-latency-and-simple-too/">written a nice DSL</a> to make wiring up the Disruptor much easier.<br /><br />EDIT 2: Note that version 2.0 of the Disruptor uses different names to the ones in this article. &nbsp;Please see&nbsp;<a href="http://mechanitis.blogspot.com/2011/08/disruptor-20-all-change-please.html">my summary of the changes</a>&nbsp;if you are confused about class names. &nbsp;Also Adrian's DSL is now part of the main Disruptor code base.<br /><ul></ul>
