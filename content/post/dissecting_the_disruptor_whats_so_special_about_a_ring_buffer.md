{
 "disqus_url" : "http://trishagee.github.io/post/dissecting_the_disruptor_whats_so_special_about_a_ring_buffer/",
 "disqus_title" : "Dissecting the Disruptor: What's so special about a ring buffer?",
 "Title": "Dissecting the Disruptor: What's so special about a ring buffer?",
 "Pubdate": "2011-06-22",
 "Keywords": ["java", "data structures", "disruptor", "lmax", "disruptor-docs"],
 "Tags": ["java", "data structures", "disruptor", "lmax", "disruptor-docs"],
 "Slug": "dissecting_the_disruptor_whats_so_special_about_a_ring_buffer",
 "Section": "post"
}
Recently we open sourced the <a href="http://code.google.com/p/disruptor/">LMAX Disruptor</a>, the key to what makes our exchange so fast. &nbsp;Why did we open source it? &nbsp;Well, we've realised that conventional wisdom around high performance programming is... a bit wrong. We've come up with a better, faster way to share data between threads, and it&nbsp;would be selfish not to share it with the world. &nbsp;Plus it makes us look dead clever.<br /><br />On the site you can <a href="https://code.google.com/p/disruptor/">download a technical article</a> explaining what the Disruptor is and why it's so clever and fast. &nbsp;I even get a writing credit on it, which is gratifying when all I really did is insert commas and re-phrase sentences I didn't understand.<br /><br />However I find the whole thing a bit much to digest all at once, so I'm going to explain it in smaller pieces, as suits my&nbsp;<a href="http://www.randsinrepose.com/archives/2003/07/10/nadd.html">NADD</a> audience.<br /><br />First up - the ring buffer. &nbsp;Initially I was under the impression the Disruptor was just the ring buffer. &nbsp;But I've come to realise that while this data structure is at the heart of the pattern, the clever bit about the Disruptor is controlling access to it. <br /><br /><b>What on earth is a ring buffer?</b><br />Well, it does what it says on the tin - it's a ring (it's circular and wraps), and you use it as a buffer to pass stuff from one context (one thread) to another:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-3gtuTbWgI-Y/TgD92AhOVxI/AAAAAAAAIDE/cWsAT81B0AI/s1600/RingBuffer.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-3gtuTbWgI-Y/TgD92AhOVxI/AAAAAAAAIDE/cWsAT81B0AI/s1600/RingBuffer.png" /></a></div><br />(OK, I drew it in Paint. &nbsp;I'm experimenting with sketch styles and hoping my OCD doesn't kick in and demand perfect circles and straight lines at precise angles).<br /><br />So basically it's an array with a pointer to the next available slot.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-WCm0iWYOrfc/TgD_cVBQExI/AAAAAAAAIDI/cEohveH8LP8/s1600/RingBufferInitial.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-WCm0iWYOrfc/TgD_cVBQExI/AAAAAAAAIDI/cEohveH8LP8/s1600/RingBufferInitial.png" /></a></div><br />As you keep filling up the buffer (and presumable reading from it too), the sequence keeps incrementing, wrapping around the ring:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-cwPlKupFfks/TgEBetHtvmI/AAAAAAAAIDM/prOjrOPDo_E/s1600/RingBufferWrapped.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-cwPlKupFfks/TgEBetHtvmI/AAAAAAAAIDM/prOjrOPDo_E/s1600/RingBufferWrapped.png" /></a></div>To find the slot in the array that the current sequence points to you use a mod operation:<br /><blockquote style="padding: 5px;">sequence mod array length = array index</blockquote>So for the above ring buffer (using Java mod syntax): <code>12 % 10 = 2</code>.  Easy.<br /><br />Actually it was a total accident that the picture had ten slots. &nbsp;Powers of two work better because computers think in binary.<br /><br /><b>So what?</b><br />If you look at Wikipedia's entry on <a href="http://en.wikipedia.org/wiki/Circular_buffer">Circular Buffers</a>, you'll see one major difference to the way we've implemented ours - we don't have a pointer to the end. &nbsp;We only have the next available sequence number. &nbsp;This is deliberate - the original reason we chose a ring buffer was so we could support reliable messaging. &nbsp;We needed a store of the messages the service had sent, so when another service sent a <a href="http://en.wikipedia.org/wiki/Nak">nak</a> to say they hadn't received some messages, it would be able to resend them.<br /><br />The ring buffer seems ideal for this. &nbsp;It stores the sequence to show where the end of the buffer is, and if it gets a nak it can replay everything from that point to the current sequence:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-r054oYKWMAM/TgHWQjn-zTI/AAAAAAAAIEM/jH73U5AChvA/s1600/RingBufferReplay.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="149" src="http://4.bp.blogspot.com/-r054oYKWMAM/TgHWQjn-zTI/AAAAAAAAIEM/jH73U5AChvA/s320/RingBufferReplay.png" width="320" /></a></div><br />The difference between the ring buffer as we've implemented it, and the queues we had traditionally been using, is that we don't consume the items in the buffer - they stay there until they get over-written. &nbsp;Which is why we don't need the "end" pointer you see in the Wikipedia version. &nbsp;Deciding whether it's OK to wrap or not is managed outside of the data structure itself (this is part of the producer and consumer behaviour - if you can't wait for me to get round to blogging about it, check out the <a href="https://code.google.com/p/disruptor/">Disruptor site</a>).<br /><br /><b>And it's so great because...?</b><br />So we use this data structure because it gives us some nice behaviour for reliable messaging. &nbsp;It turns out though that it has some other nice characteristics. <br /><br />Firstly, it's faster than something like a linked list because it's an array, and has a&nbsp;predictable&nbsp;pattern of access. &nbsp;This is nice and CPU-cache-friendly - at the hardware level the entries can be pre-loaded, so the machine is not constantly going back to main memory to load the next item in the ring.<br /><br />Secondly, it's an array and you can pre-allocate it up front, making the objects effectively immortal. &nbsp;This means the garbage collector has pretty much nothing to do here. &nbsp;Again, unlike a linked list which creates objects for every item added to the list - these then all need to be cleaned up when the item is no longer in the list.<br /><br /><b>The missing pieces</b><br />I haven't talked about how to prevent the ring wrapping, or specifics around how to write stuff to and read things from the ring buffer. &nbsp;You'll also notice I've been comparing it to a data structure like a linked list, which I don't think anyone believes is the answer to the world's problems.<br /><br />The interesting part comes when you compare the Disruptor with an implementation like a queue. &nbsp;Queues usually take care of all the stuff like the start and end of the queue, adding and consuming items, and so forth. &nbsp;All the stuff I haven't really touched on with the ring buffer. &nbsp;That's because the ring buffer itself isn't responsible for these things, we've moved these concerns outside of the data structure.<br /><br />For more details you're just going to have to <a href="https://code.google.com/p/disruptor/">read the paper or check out the code</a>. &nbsp;Or <a href="http://www.infoq.com/presentations/LMAX">watch Mike and Martin</a> at QCon San Francisco last year. &nbsp;Or wait for me to have a spare five minutes to get my head around the rest of it.
