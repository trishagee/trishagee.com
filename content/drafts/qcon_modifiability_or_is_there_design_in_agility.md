{
 "disqus_url" : "http://trishagee.github.io/post/qcon_modifiability_or_is_there_design_in_agility/",
 "disqus_title" : "QCon: Modifiability: Or is there Design in Agility?",
 "Title": "QCon: Modifiability: Or is there Design in Agility?",
 "Pubdate": "2007-03-14",
 "Slug": "qcon_modifiability_or_is_there_design_in_agility",
 "Section": "post"
}
<a href="http://www.martinfowler.com/">Martin Fowler</a>, Refactoring, Analysis Patterns (<br /><div class="ljuser"><a href="http://syndicated.livejournal.com/martinfowler/profile"><img alt="[info]" height="16" src="http://stat.livejournal.com/img/syndicated.gif" style="border: 0pt none; vertical-align: bottom;" width="16" /></a><a href="http://syndicated.livejournal.com/martinfowler/"><b>martinfowler</b></a></div>)<br /><br />- Talks about experiences of him and others at thoughtworks<br />- This was a sort of panel-based session run by Martin but featuring a bunch of real-life coders, architects, etc from <a href="http://www.thoughtworks.co.uk/index.html">Thoughtworks</a><br />- The title was about modifiability but it was a lot about up-front design and emergent architectures<br />- They said some decisions need to be made up-front, and some can be put off.&nbsp; My thought here was that it was making the call between these two things that is the hard thing, and requires experience as much as anything else.<br />- Design is still required in agile.&nbsp; It doesn't mean no design.<br />- One dude, Fred, was all about Lean.<br />- Lean = Just in Time.&nbsp; Which also applies to software, and often means waiting "until the last responsible moment" to make a decision<br />- If an "expensive" (irreversible) decision needs to be made, proceed on parallel paths until you're ready to make the choice<br />- I thought this parallel track thing was like the design stage in CDT - we always had to do at least 3 designs and make a choice, but we often picked the best from all designs and came up with something we woulnd't have thought of before<br />- Architecture is emergent but it is there - start with a model, and keep track of its changes.&nbsp; That way a) you know if a design decision makes sense and helps you put the right fix in the right place, and b) I guess it means you get to keep track of the evolving design and spot when perhaps this model makes less sense<br />- Full scale design may not be done up front but there's no reason not to lay down some "pricinples" - e.g. 3 tier model, MVC, etc.&nbsp; <br />- You can state to the client that you want to base it around these principals and have conversations which allow it to grow from there (or, I suppse, kill off inappropriate ideas before it's too late)<br />- Model the business first and not the technology, it leads to more business-focussed design.&nbsp; That way, if the user changes their mind or adds something they hadn't thought about, chances are the change will be minimal if you were modelling it upon THEIR understanding of the business instead of interpreting it into some other model.<br />- By "model" (in business context) I think the implications was that one of these models might be the automated tests.<br />- Which leads to a point about TDD as opposed to writing unit tests retrospectively - if you write the tests later chances are you're modelling the technology and not the business requirements.<br />- Direct mapping of business language into the code - for example we're talking about an "Account" not an Array or something.&nbsp; Makes it easier to communicate with the business and to ensure the mapping between the technology and the business<br />- Job is to translate business into good domain model<br />- Implementation of this model should be the "simple" bit.&nbsp; This is where the "simplest solution" bit from XP comes in.<br />- Prototyping and cheap scaffolding is fine provided you recognise it for what it is and design around it - e..g. interfaces so you can plug proper stuff into it later.&nbsp; If the prototyping / scaffolding helps you make the right decision then it's a Good Thing.<br />- <br /><div class="ljuser"><a href="http://syndicated.livejournal.com/dannorth/profile"><img alt="[info]" height="16" src="http://stat.livejournal.com/img/syndicated.gif" style="border: 0pt none; vertical-align: bottom;" width="16" /></a><a href="http://syndicated.livejournal.com/dannorth/"><b>dannorth</b></a></div>has a website which has content on <a href="http://dannorth.net/introducing-bdd/">behaviour-driven development</a>.<br />- If you do the simple things well first, the more complicated stuff falls into place<br />- You MUST communicate your decisions (esp. regarding architecture) or you risk others trampling all over them with their own ideas.&nbsp; If you have a prupose or set of principals the others must know about them and be bought into them.&nbsp; This considered, if you do this and you still find your design being trampled all over every time, that means it's not compatible with the others and you might as well let it go - it's more important the team are working together than that your perfect design is implemented.<br />- If you are pair programming with a junior person (and there are arguments in the <a href="http://www.infoq.com/articles/paul-oldfield-interview">Paul Oldfield interview </a>about advantages of equal-partner programming) then it's less about decreasing your productivity and more an investment in them.&nbsp; This is useful to remember when you consider <a href="http://www.thepragmaticarchitect.com/pages/kseal.html">Kevin's </a>argument about not doing this with offshore or potentially those who aren't from your company - you're giving them free training and increasing their abilities, potentially to the point where it harms the team because they leave to earn a bunch more money elsewhere.
