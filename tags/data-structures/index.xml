<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Data-Structures on Trisha Gee </title>
    <link>http://trishagee.github.io/tags/data-structures/index.xml</link>
    <language>en-us</language>
    <author>Trisha Gee</author>
    <rights>Copyright (c) 2011 - 2014, Trisha Gee; all rights reserved.</rights>
    <updated>Wed, 22 Jun 2011 00:00:00 UTC</updated>
    
    <item>
      <title>Dissecting the Disruptor: What&#39;s so special about a ring buffer?</title>
      <link>http://trishagee.github.io/post/dissecting_the_disruptor_whats_so_special_about_a_ring_buffer</link>
      <pubDate>Wed, 22 Jun 2011 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/dissecting_the_disruptor_whats_so_special_about_a_ring_buffer</guid>
      <description>&lt;p&gt;Recently we open sourced the &lt;a href=&#34;http://code.google.com/p/disruptor/&#34;&gt;LMAX Disruptor&lt;/a&gt;, the key to what makes our exchange so fast. &amp;nbsp;Why did we open source it? &amp;nbsp;Well, we&amp;rsquo;ve realised that conventional wisdom around high performance programming is&amp;hellip; a bit wrong. We&amp;rsquo;ve come up with a better, faster way to share data between threads, and it&amp;nbsp;would be selfish not to share it with the world. &amp;nbsp;Plus it makes us look dead clever.&lt;br /&gt;&lt;br /&gt;On the site you can &lt;a href=&#34;https://code.google.com/p/disruptor/&#34;&gt;download a technical article&lt;/a&gt; explaining what the Disruptor is and why it&amp;rsquo;s so clever and fast. &amp;nbsp;I even get a writing credit on it, which is gratifying when all I really did is insert commas and re-phrase sentences I didn&amp;rsquo;t understand.&lt;br /&gt;&lt;br /&gt;However I find the whole thing a bit much to digest all at once, so I&amp;rsquo;m going to explain it in smaller pieces, as suits my&amp;nbsp;&lt;a href=&#34;http://www.randsinrepose.com/archives/2003/07/10/nadd.html&#34;&gt;NADD&lt;/a&gt; audience.&lt;br /&gt;&lt;br /&gt;First up - the ring buffer. &amp;nbsp;Initially I was under the impression the Disruptor was just the ring buffer. &amp;nbsp;But I&amp;rsquo;ve come to realise that while this data structure is at the heart of the pattern, the clever bit about the Disruptor is controlling access to it. &lt;br /&gt;&lt;br /&gt;&lt;b&gt;What on earth is a ring buffer?&lt;/b&gt;&lt;br /&gt;Well, it does what it says on the tin - it&amp;rsquo;s a ring (it&amp;rsquo;s circular and wraps), and you use it as a buffer to pass stuff from one context (one thread) to another:&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://1.bp.blogspot.com/-3gtuTbWgI-Y/TgD92AhOVxI/AAAAAAAAIDE/cWsAT81B0AI/s1600/RingBuffer.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://1.bp.blogspot.com/-3gtuTbWgI-Y/TgD92AhOVxI/AAAAAAAAIDE/cWsAT81B0AI/s1600/RingBuffer.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;(OK, I drew it in Paint. &amp;nbsp;I&amp;rsquo;m experimenting with sketch styles and hoping my OCD doesn&amp;rsquo;t kick in and demand perfect circles and straight lines at precise angles).&lt;br /&gt;&lt;br /&gt;So basically it&amp;rsquo;s an array with a pointer to the next available slot.&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://4.bp.blogspot.com/-WCm0iWYOrfc/TgD_cVBQExI/AAAAAAAAIDI/cEohveH8LP8/s1600/RingBufferInitial.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://4.bp.blogspot.com/-WCm0iWYOrfc/TgD_cVBQExI/AAAAAAAAIDI/cEohveH8LP8/s1600/RingBufferInitial.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;As you keep filling up the buffer (and presumable reading from it too), the sequence keeps incrementing, wrapping around the ring:&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/-cwPlKupFfks/TgEBetHtvmI/AAAAAAAAIDM/prOjrOPDo_E/s1600/RingBufferWrapped.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://2.bp.blogspot.com/-cwPlKupFfks/TgEBetHtvmI/AAAAAAAAIDM/prOjrOPDo_E/s1600/RingBufferWrapped.png&#34; /&gt;&lt;/a&gt;&lt;/div&gt;To find the slot in the array that the current sequence points to you use a mod operation:&lt;br /&gt;&lt;blockquote style=&#34;padding: 5px;&#34;&gt;sequence mod array length = array index&lt;/blockquote&gt;So for the above ring buffer (using Java mod syntax): &lt;code&gt;12 % 10 = 2&lt;/code&gt;.  Easy.&lt;br /&gt;&lt;br /&gt;Actually it was a total accident that the picture had ten slots. &amp;nbsp;Powers of two work better because computers think in binary.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;So what?&lt;/b&gt;&lt;br /&gt;If you look at Wikipedia&amp;rsquo;s entry on &lt;a href=&#34;http://en.wikipedia.org/wiki/Circular_buffer&#34;&gt;Circular Buffers&lt;/a&gt;, you&amp;rsquo;ll see one major difference to the way we&amp;rsquo;ve implemented ours - we don&amp;rsquo;t have a pointer to the end. &amp;nbsp;We only have the next available sequence number. &amp;nbsp;This is deliberate - the original reason we chose a ring buffer was so we could support reliable messaging. &amp;nbsp;We needed a store of the messages the service had sent, so when another service sent a &lt;a href=&#34;http://en.wikipedia.org/wiki/Nak&#34;&gt;nak&lt;/a&gt; to say they hadn&amp;rsquo;t received some messages, it would be able to resend them.&lt;br /&gt;&lt;br /&gt;The ring buffer seems ideal for this. &amp;nbsp;It stores the sequence to show where the end of the buffer is, and if it gets a nak it can replay everything from that point to the current sequence:&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://4.bp.blogspot.com/-r054oYKWMAM/TgHWQjn-zTI/AAAAAAAAIEM/jH73U5AChvA/s1600/RingBufferReplay.png&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;149&#34; src=&#34;http://4.bp.blogspot.com/-r054oYKWMAM/TgHWQjn-zTI/AAAAAAAAIEM/jH73U5AChvA/s320/RingBufferReplay.png&#34; width=&#34;320&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The difference between the ring buffer as we&amp;rsquo;ve implemented it, and the queues we had traditionally been using, is that we don&amp;rsquo;t consume the items in the buffer - they stay there until they get over-written. &amp;nbsp;Which is why we don&amp;rsquo;t need the &amp;ldquo;end&amp;rdquo; pointer you see in the Wikipedia version. &amp;nbsp;Deciding whether it&amp;rsquo;s OK to wrap or not is managed outside of the data structure itself (this is part of the producer and consumer behaviour - if you can&amp;rsquo;t wait for me to get round to blogging about it, check out the &lt;a href=&#34;https://code.google.com/p/disruptor/&#34;&gt;Disruptor site&lt;/a&gt;).&lt;br /&gt;&lt;br /&gt;&lt;b&gt;And it&amp;rsquo;s so great because&amp;hellip;?&lt;/b&gt;&lt;br /&gt;So we use this data structure because it gives us some nice behaviour for reliable messaging. &amp;nbsp;It turns out though that it has some other nice characteristics. &lt;br /&gt;&lt;br /&gt;Firstly, it&amp;rsquo;s faster than something like a linked list because it&amp;rsquo;s an array, and has a&amp;nbsp;predictable&amp;nbsp;pattern of access. &amp;nbsp;This is nice and CPU-cache-friendly - at the hardware level the entries can be pre-loaded, so the machine is not constantly going back to main memory to load the next item in the ring.&lt;br /&gt;&lt;br /&gt;Secondly, it&amp;rsquo;s an array and you can pre-allocate it up front, making the objects effectively immortal. &amp;nbsp;This means the garbage collector has pretty much nothing to do here. &amp;nbsp;Again, unlike a linked list which creates objects for every item added to the list - these then all need to be cleaned up when the item is no longer in the list.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;The missing pieces&lt;/b&gt;&lt;br /&gt;I haven&amp;rsquo;t talked about how to prevent the ring wrapping, or specifics around how to write stuff to and read things from the ring buffer. &amp;nbsp;You&amp;rsquo;ll also notice I&amp;rsquo;ve been comparing it to a data structure like a linked list, which I don&amp;rsquo;t think anyone believes is the answer to the world&amp;rsquo;s problems.&lt;br /&gt;&lt;br /&gt;The interesting part comes when you compare the Disruptor with an implementation like a queue. &amp;nbsp;Queues usually take care of all the stuff like the start and end of the queue, adding and consuming items, and so forth. &amp;nbsp;All the stuff I haven&amp;rsquo;t really touched on with the ring buffer. &amp;nbsp;That&amp;rsquo;s because the ring buffer itself isn&amp;rsquo;t responsible for these things, we&amp;rsquo;ve moved these concerns outside of the data structure.&lt;br /&gt;&lt;br /&gt;For more details you&amp;rsquo;re just going to have to &lt;a href=&#34;https://code.google.com/p/disruptor/&#34;&gt;read the paper or check out the code&lt;/a&gt;. &amp;nbsp;Or &lt;a href=&#34;http://www.infoq.com/presentations/LMAX&#34;&gt;watch Mike and Martin&lt;/a&gt; at QCon San Francisco last year. &amp;nbsp;Or wait for me to have a spare five minutes to get my head around the rest of it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
