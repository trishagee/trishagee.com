<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Java-5 on Trisha Gee </title>
    <link>http://trishagee.github.io/tags/java-5/index.xml</link>
    <language>en-us</language>
    <author>Trisha Gee</author>
    <rights>Copyright (c) 2011 - 2014, Trisha Gee; all rights reserved.</rights>
    <updated>Mon, 14 Apr 2008 00:00:00 UTC</updated>
    
    <item>
      <title>AOP Caching</title>
      <link>http://trishagee.github.io/post/aop_caching</link>
      <pubDate>Mon, 14 Apr 2008 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/aop_caching</guid>
      <description>&lt;p&gt;&lt;p&gt;Today I would like to document my experiences implementing caching with Aspect Oriented Programming (AOP) and annotations.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Background context&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Caching may need to be implemented in your application for a number of reasons. OK, actually usually only one: performance. I would like to add my own tuppence-worth to this though - if you can get away without caching (specifically in application that provide the ability to view and change data) then do so, unless you are using a cache implementation that will handle as much of the pain as possible for you. Implementing a home-grown cache from scratch is almost never the correct thing to do in my experience, you spend lots of time debugging and tweaking the cache when you should be working on your day-job, not re-inventing something that &lt;a href=&#34;http://java-source.net/open-source/cache-solutions&#34;&gt;someone, somewhere, has already done a perfectly good job of&lt;/a&gt;.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The example I&amp;rsquo;m about to show you is for a web application created to let users read and edit values from a database (not an unusual scenario!).&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Application Architecture&lt;/b&gt;&amp;nbsp;&lt;br /&gt;The application architecture I have assumed for this example is:&amp;nbsp;&lt;br /&gt;Java 1.5, JSP, Spring MVC (2.0.1), Spring JDBC (2.0.4), running on Tomcat 5.5, connecting to a database (RDBMS type not important for this example).&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;OSCache&lt;/b&gt;&amp;nbsp;&lt;br /&gt;A third party library, &lt;a href=&#34;http://www.opensymphony.com/oscache/&#34;&gt;OSCache&lt;/a&gt;, provides the underlying cache for the application. This was chosen because it provides a simple solution which is easy to integrate into our Spring MVC layer and also provides JSP-level caching should we need it later.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The application uses OSCache in a very basic way. Caching could&amp;rsquo;ve been implemented with a HashMap and it wouldn’t have provided much less functionality (the way I&amp;rsquo;m using it), but by using OSCache we can using the &amp;ldquo;group&amp;rdquo; functionality (which allows us to cache against a key AND a group name, so we can flush and reload a whole group if necessary), and we can potentially add timeouts and other more complex functionality simply with configuration changes. See the OSCache documentation for full details.&amp;nbsp;&lt;b&gt;&lt;br /&gt;&lt;br /&gt;CacheManager&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Primarily to aid unit testing, but also to provide some separation between the application and the implementation of the caching mechanism, a CacheManager interface was implemented, and the implementation version simply wraps the OSCache GeneralCacheAdministrator.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Aspect Oriented Programming for Caching&lt;/b&gt;&amp;nbsp;&lt;br /&gt;If caching is implemented in a very simple way, it can be easy to forget to handle caching on all methods that require it. Also, the code to check something is in the cache and retrieve it from the database and store it in the cache if it is not, is standard for most functions. Therefore it seemed to make sense to implement caching using Aspect Oriented Programming, so it can cut across all functionality without it having to be explicitly declared in every method that might need to utilise the cache.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Spring has &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.1/reference/aop.html&#34;&gt;built-in support for AOP&lt;/a&gt; (and that documentation also provides a good introduction to what AOP is), so given our use of Spring MVC it shouldn&amp;rsquo;t be too complicated to add Aspects to our code.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: Application Context file&lt;/b&gt;&amp;nbsp;&lt;br /&gt;You need to add a couple of things to the application context file for your app to set up the cache and enable the AOP.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;pre&gt;&amp;lt;!&amp;ndash; Initialisation for Caching &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;!&amp;ndash; the actual cache &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;bean&amp;nbsp;id=&amp;ldquo;cacheAdministrator&amp;rdquo; &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class=&amp;ldquo;com.opensymphony.oscache.general.GeneralCacheAdministrator&amp;rdquo; &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; destroy-method=&amp;ldquo;destroy&amp;rdquo;/&amp;gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;bean id=&amp;ldquo;cacheManager&amp;rdquo; class=&amp;rdquo; com.mechanitis.examples.cache.impl.CacheManagerImpl&amp;rdquo;&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;property name=&amp;ldquo;cacheAdministrator&amp;rdquo; ref=&amp;ldquo;cacheAdministrator&amp;rdquo;/&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;!&amp;ndash; Magic to get the Spring aspectJ-style AOP working &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;!&amp;ndash; Code that does the caching (the Aspect) &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;bean&amp;nbsp;id=&amp;ldquo;cacheAOP&amp;rdquo; class=&amp;ldquo;com.mechanitis.examples.aspect.CachingAspects&amp;rdquo;&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;property name=&amp;ldquo;cache&amp;rdquo; ref=&amp;ldquo;cacheManager&amp;rdquo; /&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;&amp;lt;!&amp;ndash; End of Caching setup &amp;ndash;&amp;gt;&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;Note that, like the &lt;a href=&#34;http://mechanitis.livejournal.com/7127.html&#34;&gt;validation&lt;/a&gt;, this makes use of schema-based configuration.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Now these settings are in the configuration file, they should not need to be changed unless the cache provider is changed or caching is to be fundamentally altered.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: Defining Items to be Cached&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Originally I had the application &amp;ldquo;magically&amp;rdquo; caching anything returned from a “get” method in the service layer and purging the cache on any “save” or “update” method.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;However there are some types of objects that don’t need to be cached and cause errors when they do, as sometimes the data needs to be &amp;ldquo;fresh&amp;rdquo; from the database. So the service layer declares what needs attention from the cache manager by the use of annotations: &lt;/p&gt;&lt;pre&gt;import com.mechanitis.examples.cache.Cache;&lt;br/&gt;// &amp;hellip;more imports&amp;hellip;&lt;br/&gt;&lt;br/&gt;public class CustomerServiceImpl implements CustomerService {&lt;br/&gt;  private static final String CUSTOMER_CACHE_GROUP = &amp;ldquo;Customer&amp;rdquo;;&lt;br/&gt; private static final String BRANCH_CACHE_GROUP = &amp;ldquo;Branch&amp;rdquo;;&lt;br/&gt;&lt;br/&gt;    private CustomerDAO customerDAO;&lt;br/&gt;   &lt;br/&gt;   @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public Client getCustomer(CustomerId customerId) {&lt;br/&gt;     return customerDAO.getCustomer(customerId);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public ClientId saveCustomer(Customer customer, String username) {&lt;br/&gt;     return customerDAO.saveCustomer(customer, username);&lt;br/&gt;   }&lt;br/&gt;  &lt;br/&gt;   @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public void updateCustomer(Customer customer) {&lt;br/&gt;        this.customerDAO.updateCustomer(customer);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; @Cache(groups={CUSTOMER_CACHE_GROUP,BRANCH_CACHE_GROUP})&lt;br/&gt;   public void saveCustomerBranch(CustomerBranch customerBranch) {&lt;br/&gt;        customerDAO.saveCustomerBranch (customerBranch);&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;You may notice that this service doesn’t really add much value – it forwards the request to the DAO and little else. The purpose of the service layer, however, is to provide a simple place for things like caching, and in future potentially additional security, logging, transactions, or to string together multiple calls to DAOs for a more complex transaction.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The methods that return objects that need to be cached or that affect items in the cache are tagged with the @Cache &lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html&#34;&gt;annotation&lt;/a&gt;. The single argument to this is a list of the groups in the cache that the Object should be or already is associated with. This group allows selective flushing of the cache – so when a new Customer is added, only the Customer group gets flushed (and consequently refreshed) rather than the whole cache.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Note that these annotations have to be on the implementation class of the service layer, not the interface – this is because it&amp;rsquo;s the implementation that is wrapped by the AOP proxy. For more information see &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.1/reference/aop.html#aop-understanding-aop-proxies&#34;&gt;Understanding AOP Proxies&lt;/a&gt;.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: CachingAspects&lt;br /&gt;&lt;/b&gt;This class is responsible for most of the work around the caching mechanism. It defines which methods in the service layer require attention from the caching mechanism and it performs the work around retrieving from the cache and dealing with cache misses.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;It uses the AspectJ AOP conventions in Spring 2.0, more information of which can be found in the &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.x/reference/aop.html#aop-ataspectj&#34;&gt;Spring documentation&lt;/a&gt;. The main areas of interest are the annotations for each method which state when this method is to be called: &lt;pre&gt;@Around(&amp;ldquo;execution(@com.mechanitis.examples.cache.Cache java.util.List get* ())&amp;ldquo;)&lt;br/&gt;public Object cacheListWithNoArgs(ProceedingJoinPoint pjp) throws Throwable {&amp;hellip;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;This states that this method should be called when any method that starts with the word &amp;ldquo;get&amp;rdquo; that returns a List and is tagged with the @Cache annotation is called. The @Around states that this method will be responsible for calling the original method – so in this case the original service method that was called (e.g. CustomerService.getAllCustomers()) will only be called if the list not is found in the cache. Another example is: &lt;pre&gt;@Around(&amp;ldquo;execution(@com.mechanitis.examples.cache.Cache “&lt;br/&gt;      + &amp;ldquo; com.mechanitis.examples.common.domain.* &amp;ldquo;&lt;br/&gt;      + &amp;ldquo;get* (com.mechanitis.examples.domain.id.*))&amp;ldquo;)&lt;br/&gt;public Object getIdentifiableObject(ProceedingJoinPoint pjp) throws Throwable {&amp;hellip;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;This method is called when a service method is called that is tagged with the @Cache annotation, starts with “get”, is passed a domain ID and returns a domain object. This is a classic example of something to be dealt with by the cache manager – again it needs to check if the item is in the cache, return it if it is or retrieve it from its original source and store it in the cache if it is not. You can have similar methods for determining which methods need to flush the cache (e.g. &amp;ldquo;update&amp;rdquo; or &amp;ldquo;create&amp;rdquo; methods).&amp;nbsp;&lt;br /&gt;&lt;br /&gt;And hey presto! An almost magical cache which does not require your developers to re-write the same caching code for all the &amp;ldquo;get&amp;rdquo;, &amp;ldquo;update&amp;rdquo; and &amp;ldquo;create&amp;rdquo; methods on your service layer. All they have to do is tag the appropriate methods with @Cache and the AOP will take care of the rest of it.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Disadvantages to AOP&lt;/b&gt;&amp;nbsp;&lt;br /&gt;As with many “magical” implementations, the main issue I found with this implementation of an AOP cache is that it can be difficult to debug. Caching can cause weird issues anyway (for example, if your update methods don’t correctly flush the cache you get old data being displayed, or if your cache update method doesn’t correctly retrieve the data). But when you throw Aspects into the mix, it can cause some interesting bugs that are hard to track down.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The number one key to helping to overcome this issue is a good set of unit/functional tests for your cache. The advantage of testing a centralised AOP cache is that you don’t have to thoroughly test every method that might have caching implemented. So writing a lot of good tests for the AOP cache probably pays off vs. implementing and testing caching for individual methods.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Still, strange things can creep in that can’t be detected by unit tests. For example, if a method has been tagged as a cache method through careless copy-paste coding, when it needs real-time data. Or, as I found, worse – if you don’t have a way to explicitly state which methods require caching but do it through the magic of naming conventions, you need all your developers to be fully aware of these conventions (and to not make mistakes in this area) in order to state which methods use the cache and which do not.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Although I probably spent more time tweaking and debugging the cache than almost any other individual area of the application when I used it in anger, I would still say it was worthwhile implementing it in this fashion. The benefits from removing any “difficult” bits from the service layer, so junior developers can happily work, and the ease of adding an annotation to the appropriate methods, I think improved productivity enough and allowed for much cleaner code (which also improves productivity) so that it was the right choice to make.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java Specifics</title>
      <link>http://trishagee.github.io/post/java_specifics</link>
      <pubDate>Sat, 07 Jul 2007 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/java_specifics</guid>
      <description>&lt;p&gt;When I first started playing with Java 1.5, I thought &lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&#34;&gt;generics&lt;/a&gt; were the best thing since sliced bread.  No more untidy casting, lovely type-safe Collections, and when combined with the &lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/guide/language/foreach.html&#34;&gt;new for loop&lt;/a&gt;, a lot of the tedious tasks associated with Collections became easier and, most importantly, aesthetically pleasing.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Consider the old code:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;       List list = new ArrayList();&lt;br/&gt;       list.add(new Integer(1));&lt;br/&gt;      Integer integer = (Integer)list.get(0);&lt;br/&gt;&lt;br/&gt;       for (Iterator i = list.iterator(); i.hasNext(); ) {&lt;br/&gt;            Integer number = (Integer)i.next();&lt;br/&gt;            number.intValue();&lt;br/&gt;     }&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;And the new:&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;       List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;     list.add(new Integer(2));&lt;br/&gt;      Integer integer = list.get(0);&lt;br/&gt;&lt;br/&gt;        for (Integer number : list) {&lt;br/&gt;          number.intValue();&lt;br/&gt;     }&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;See?  Much prettier.  OK so it&amp;rsquo;s a silly little example but when you apply it to all the places you use things like Collections it does make life a lot easier, especially when you consider that now you &lt;em&gt;know&lt;/em&gt; what&amp;rsquo;s in that List that comes back from some method that you&amp;rsquo;re not familiar with.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Nearly two years on from the first time I started using them, I run into an issue - they&amp;rsquo;re not generic at all.  They&amp;rsquo;re specific.  The point about generics as far as I can figure out is type-safety - they remove the need to cast everything everywhere.  Which is great, until you actually want a little flexibility in your types.  So, you can have the code above which adds and retrieves Integers from a list, knowing that it&amp;rsquo;s perfectly fine to get objects from that list and treat them as Integers because that&amp;rsquo;s exactly what they are.  But what you can&amp;rsquo;t do is assign a List of some subtype to a List of one if its supertypes:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt; public List&amp;lt;Integer&amp;gt; getIntegers() {&lt;br/&gt;     List&amp;lt;Integer&amp;gt; integers = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;     integers.add(new Integer(1));&lt;br/&gt;      return integers;&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt; &amp;hellip;&lt;br/&gt;&lt;br/&gt;   public void assignList() {&lt;br/&gt;     List&amp;lt;Number&amp;gt; numbers = getIntegers(); //compiler error - Type mismatch&lt;br/&gt;       //or&lt;br/&gt;       numbers = new ArrayList&amp;lt;Integer&amp;gt;(); //compiler error - Type mismatch&lt;br/&gt; }&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;OK fine, it&amp;rsquo;s a bit confusing but it makes sense if you think about it.  A good example is provided in &lt;a href=&#34;http://www.ibm.com/developerworks/java/library/j-jtp01255.html&#34;&gt;this article&lt;/a&gt;, which explains that if you&amp;rsquo;re expecting a Collection of Numbers, you might expect to be able to add a Float to it, but if lurking under the covers you&amp;rsquo;ve assigned a List of Integers to it, it is incorrect to add a Float to it.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;So what about wildcards?  Aren&amp;rsquo;t they supposed to overcome this issue?  Well, &lt;a href=&#34;http://www.netalive.org/swsu/archives/2005/07/generics_wildca.html&#34;&gt;sort of&lt;/a&gt;.  Wildcards in generics means you can do the following:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;        List&amp;lt;? extends Number&amp;gt; numbers = getIntegers();&lt;br/&gt;      //or&lt;br/&gt;       numbers = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;and this will not give a compiler error.  But then you can&amp;rsquo;t do:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;      List&amp;lt;? extends Number&amp;gt; numbers = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;     numbers.addAll(new ArrayList&amp;lt;Integer&amp;gt;()); //compiler error&lt;br/&gt;       numbers.add(new Integer(1)); //compiler error&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;So you can use a wildcarded Collection to represent that you know that Collection is going to be some Collection that contains something that is a subclass of Number (for example), but not to say that the Collection can contain any mix of items that are a sublasses of number.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;OK&amp;hellip; what do I need to remember to prevent confusion in future?&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Well, looks like we use:&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;       List&amp;lt;Number&amp;gt; numbers = new ArrayList&amp;lt;Number&amp;gt;();&lt;br/&gt;        numbers.add(new Integer(1));&lt;br/&gt;       numbers.add(new Double(1));&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;if you want your collection to contain a mix of items that are subclasses of your specified generic type.  But you might have to use something like &lt;code&gt;addAll&lt;/code&gt; to insert the contents of some other List into it, as you can&amp;rsquo;t assign Lists of subclasses to it.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;If you want to assign Lists that have a generic type that&amp;rsquo;s a subclass, then you want to use wildcards:&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;      List&amp;lt;? extends Number&amp;gt; numbers = getIntegers();&lt;br/&gt;      //or&lt;br/&gt;       numbers = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;So, easy then.  No idea what I got so confused about.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
