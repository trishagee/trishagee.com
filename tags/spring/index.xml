<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Spring on Trisha Gee </title>
    <link>http://trishagee.github.io/tags/spring/index.xml</link>
    <language>en-us</language>
    <author>Trisha Gee</author>
    <rights>Copyright (c) 2011 - 2014, Trisha Gee; all rights reserved.</rights>
    <updated>Wed, 08 Oct 2008 00:00:00 UTC</updated>
    
    <item>
      <title>Amazing!</title>
      <link>http://trishagee.github.io/post/amazing</link>
      <pubDate>Wed, 08 Oct 2008 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/amazing</guid>
      <description>&lt;p&gt;Today, I found my own blog useful.&amp;nbsp; I was configuring Spring validation on my new project, and had to &lt;a href=&#34;http://mechanitis.livejournal.com/7127.html&#34;&gt;remind myself how to do it&lt;/a&gt;.&amp;nbsp; We configured validation on the new project in less than an hour, which beats the two days it took me to work out how to do it the first time.&lt;br /&gt;&lt;br /&gt;And I impressed one of my new work collegues.&amp;nbsp; Apparently I&amp;nbsp;am now the Spring Guru.&amp;nbsp; Oooops.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AOP Caching</title>
      <link>http://trishagee.github.io/post/aop_caching</link>
      <pubDate>Mon, 14 Apr 2008 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/aop_caching</guid>
      <description>&lt;p&gt;&lt;p&gt;Today I would like to document my experiences implementing caching with Aspect Oriented Programming (AOP) and annotations.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Background context&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Caching may need to be implemented in your application for a number of reasons. OK, actually usually only one: performance. I would like to add my own tuppence-worth to this though - if you can get away without caching (specifically in application that provide the ability to view and change data) then do so, unless you are using a cache implementation that will handle as much of the pain as possible for you. Implementing a home-grown cache from scratch is almost never the correct thing to do in my experience, you spend lots of time debugging and tweaking the cache when you should be working on your day-job, not re-inventing something that &lt;a href=&#34;http://java-source.net/open-source/cache-solutions&#34;&gt;someone, somewhere, has already done a perfectly good job of&lt;/a&gt;.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The example I&amp;rsquo;m about to show you is for a web application created to let users read and edit values from a database (not an unusual scenario!).&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Application Architecture&lt;/b&gt;&amp;nbsp;&lt;br /&gt;The application architecture I have assumed for this example is:&amp;nbsp;&lt;br /&gt;Java 1.5, JSP, Spring MVC (2.0.1), Spring JDBC (2.0.4), running on Tomcat 5.5, connecting to a database (RDBMS type not important for this example).&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;OSCache&lt;/b&gt;&amp;nbsp;&lt;br /&gt;A third party library, &lt;a href=&#34;http://www.opensymphony.com/oscache/&#34;&gt;OSCache&lt;/a&gt;, provides the underlying cache for the application. This was chosen because it provides a simple solution which is easy to integrate into our Spring MVC layer and also provides JSP-level caching should we need it later.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The application uses OSCache in a very basic way. Caching could&amp;rsquo;ve been implemented with a HashMap and it wouldn’t have provided much less functionality (the way I&amp;rsquo;m using it), but by using OSCache we can using the &amp;ldquo;group&amp;rdquo; functionality (which allows us to cache against a key AND a group name, so we can flush and reload a whole group if necessary), and we can potentially add timeouts and other more complex functionality simply with configuration changes. See the OSCache documentation for full details.&amp;nbsp;&lt;b&gt;&lt;br /&gt;&lt;br /&gt;CacheManager&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Primarily to aid unit testing, but also to provide some separation between the application and the implementation of the caching mechanism, a CacheManager interface was implemented, and the implementation version simply wraps the OSCache GeneralCacheAdministrator.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Aspect Oriented Programming for Caching&lt;/b&gt;&amp;nbsp;&lt;br /&gt;If caching is implemented in a very simple way, it can be easy to forget to handle caching on all methods that require it. Also, the code to check something is in the cache and retrieve it from the database and store it in the cache if it is not, is standard for most functions. Therefore it seemed to make sense to implement caching using Aspect Oriented Programming, so it can cut across all functionality without it having to be explicitly declared in every method that might need to utilise the cache.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Spring has &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.1/reference/aop.html&#34;&gt;built-in support for AOP&lt;/a&gt; (and that documentation also provides a good introduction to what AOP is), so given our use of Spring MVC it shouldn&amp;rsquo;t be too complicated to add Aspects to our code.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: Application Context file&lt;/b&gt;&amp;nbsp;&lt;br /&gt;You need to add a couple of things to the application context file for your app to set up the cache and enable the AOP.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;pre&gt;&amp;lt;!&amp;ndash; Initialisation for Caching &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;!&amp;ndash; the actual cache &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;bean&amp;nbsp;id=&amp;ldquo;cacheAdministrator&amp;rdquo; &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; class=&amp;ldquo;com.opensymphony.oscache.general.GeneralCacheAdministrator&amp;rdquo; &lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; destroy-method=&amp;ldquo;destroy&amp;rdquo;/&amp;gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;bean id=&amp;ldquo;cacheManager&amp;rdquo; class=&amp;rdquo; com.mechanitis.examples.cache.impl.CacheManagerImpl&amp;rdquo;&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;lt;property name=&amp;ldquo;cacheAdministrator&amp;rdquo; ref=&amp;ldquo;cacheAdministrator&amp;rdquo;/&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;!&amp;ndash; Magic to get the Spring aspectJ-style AOP working &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;aop:aspectj-autoproxy /&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;lt;!&amp;ndash; Code that does the caching (the Aspect) &amp;ndash;&amp;gt;&lt;br /&gt;&amp;lt;bean&amp;nbsp;id=&amp;ldquo;cacheAOP&amp;rdquo; class=&amp;ldquo;com.mechanitis.examples.aspect.CachingAspects&amp;rdquo;&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;property name=&amp;ldquo;cache&amp;rdquo; ref=&amp;ldquo;cacheManager&amp;rdquo; /&amp;gt;&lt;br /&gt;&amp;lt;/bean&amp;gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt;&amp;lt;!&amp;ndash; End of Caching setup &amp;ndash;&amp;gt;&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;Note that, like the &lt;a href=&#34;http://mechanitis.livejournal.com/7127.html&#34;&gt;validation&lt;/a&gt;, this makes use of schema-based configuration.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Now these settings are in the configuration file, they should not need to be changed unless the cache provider is changed or caching is to be fundamentally altered.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: Defining Items to be Cached&lt;/b&gt;&amp;nbsp;&lt;br /&gt;Originally I had the application &amp;ldquo;magically&amp;rdquo; caching anything returned from a “get” method in the service layer and purging the cache on any “save” or “update” method.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;However there are some types of objects that don’t need to be cached and cause errors when they do, as sometimes the data needs to be &amp;ldquo;fresh&amp;rdquo; from the database. So the service layer declares what needs attention from the cache manager by the use of annotations: &lt;/p&gt;&lt;pre&gt;import com.mechanitis.examples.cache.Cache;&lt;br/&gt;// &amp;hellip;more imports&amp;hellip;&lt;br/&gt;&lt;br/&gt;public class CustomerServiceImpl implements CustomerService {&lt;br/&gt;  private static final String CUSTOMER_CACHE_GROUP = &amp;ldquo;Customer&amp;rdquo;;&lt;br/&gt; private static final String BRANCH_CACHE_GROUP = &amp;ldquo;Branch&amp;rdquo;;&lt;br/&gt;&lt;br/&gt;    private CustomerDAO customerDAO;&lt;br/&gt;   &lt;br/&gt;   @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public Client getCustomer(CustomerId customerId) {&lt;br/&gt;     return customerDAO.getCustomer(customerId);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public ClientId saveCustomer(Customer customer, String username) {&lt;br/&gt;     return customerDAO.saveCustomer(customer, username);&lt;br/&gt;   }&lt;br/&gt;  &lt;br/&gt;   @Cache(groups=CUSTOMER_CACHE_GROUP)&lt;br/&gt;    public void updateCustomer(Customer customer) {&lt;br/&gt;        this.customerDAO.updateCustomer(customer);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; @Cache(groups={CUSTOMER_CACHE_GROUP,BRANCH_CACHE_GROUP})&lt;br/&gt;   public void saveCustomerBranch(CustomerBranch customerBranch) {&lt;br/&gt;        customerDAO.saveCustomerBranch (customerBranch);&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;You may notice that this service doesn’t really add much value – it forwards the request to the DAO and little else. The purpose of the service layer, however, is to provide a simple place for things like caching, and in future potentially additional security, logging, transactions, or to string together multiple calls to DAOs for a more complex transaction.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The methods that return objects that need to be cached or that affect items in the cache are tagged with the @Cache &lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html&#34;&gt;annotation&lt;/a&gt;. The single argument to this is a list of the groups in the cache that the Object should be or already is associated with. This group allows selective flushing of the cache – so when a new Customer is added, only the Customer group gets flushed (and consequently refreshed) rather than the whole cache.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Note that these annotations have to be on the implementation class of the service layer, not the interface – this is because it&amp;rsquo;s the implementation that is wrapped by the AOP proxy. For more information see &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.1/reference/aop.html#aop-understanding-aop-proxies&#34;&gt;Understanding AOP Proxies&lt;/a&gt;.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Implementation: CachingAspects&lt;br /&gt;&lt;/b&gt;This class is responsible for most of the work around the caching mechanism. It defines which methods in the service layer require attention from the caching mechanism and it performs the work around retrieving from the cache and dealing with cache misses.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;It uses the AspectJ AOP conventions in Spring 2.0, more information of which can be found in the &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.x/reference/aop.html#aop-ataspectj&#34;&gt;Spring documentation&lt;/a&gt;. The main areas of interest are the annotations for each method which state when this method is to be called: &lt;pre&gt;@Around(&amp;ldquo;execution(@com.mechanitis.examples.cache.Cache java.util.List get* ())&amp;ldquo;)&lt;br/&gt;public Object cacheListWithNoArgs(ProceedingJoinPoint pjp) throws Throwable {&amp;hellip;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;This states that this method should be called when any method that starts with the word &amp;ldquo;get&amp;rdquo; that returns a List and is tagged with the @Cache annotation is called. The @Around states that this method will be responsible for calling the original method – so in this case the original service method that was called (e.g. CustomerService.getAllCustomers()) will only be called if the list not is found in the cache. Another example is: &lt;pre&gt;@Around(&amp;ldquo;execution(@com.mechanitis.examples.cache.Cache “&lt;br/&gt;      + &amp;ldquo; com.mechanitis.examples.common.domain.* &amp;ldquo;&lt;br/&gt;      + &amp;ldquo;get* (com.mechanitis.examples.domain.id.*))&amp;ldquo;)&lt;br/&gt;public Object getIdentifiableObject(ProceedingJoinPoint pjp) throws Throwable {&amp;hellip;}&lt;br/&gt;&lt;/pre&gt;&lt;br /&gt;This method is called when a service method is called that is tagged with the @Cache annotation, starts with “get”, is passed a domain ID and returns a domain object. This is a classic example of something to be dealt with by the cache manager – again it needs to check if the item is in the cache, return it if it is or retrieve it from its original source and store it in the cache if it is not. You can have similar methods for determining which methods need to flush the cache (e.g. &amp;ldquo;update&amp;rdquo; or &amp;ldquo;create&amp;rdquo; methods).&amp;nbsp;&lt;br /&gt;&lt;br /&gt;And hey presto! An almost magical cache which does not require your developers to re-write the same caching code for all the &amp;ldquo;get&amp;rdquo;, &amp;ldquo;update&amp;rdquo; and &amp;ldquo;create&amp;rdquo; methods on your service layer. All they have to do is tag the appropriate methods with @Cache and the AOP will take care of the rest of it.&amp;nbsp;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;Disadvantages to AOP&lt;/b&gt;&amp;nbsp;&lt;br /&gt;As with many “magical” implementations, the main issue I found with this implementation of an AOP cache is that it can be difficult to debug. Caching can cause weird issues anyway (for example, if your update methods don’t correctly flush the cache you get old data being displayed, or if your cache update method doesn’t correctly retrieve the data). But when you throw Aspects into the mix, it can cause some interesting bugs that are hard to track down.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;The number one key to helping to overcome this issue is a good set of unit/functional tests for your cache. The advantage of testing a centralised AOP cache is that you don’t have to thoroughly test every method that might have caching implemented. So writing a lot of good tests for the AOP cache probably pays off vs. implementing and testing caching for individual methods.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Still, strange things can creep in that can’t be detected by unit tests. For example, if a method has been tagged as a cache method through careless copy-paste coding, when it needs real-time data. Or, as I found, worse – if you don’t have a way to explicitly state which methods require caching but do it through the magic of naming conventions, you need all your developers to be fully aware of these conventions (and to not make mistakes in this area) in order to state which methods use the cache and which do not.&amp;nbsp;&lt;br /&gt;&lt;br /&gt;Although I probably spent more time tweaking and debugging the cache than almost any other individual area of the application when I used it in anger, I would still say it was worthwhile implementing it in this fashion. The benefits from removing any “difficult” bits from the service layer, so junior developers can happily work, and the ease of adding an annotation to the appropriate methods, I think improved productivity enough and allowed for much cleaner code (which also improves productivity) so that it was the right choice to make.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Validation with Spring Modules Validation</title>
      <link>http://trishagee.github.io/post/validation_with_spring_modules_validation</link>
      <pubDate>Mon, 16 Jul 2007 00:00:00 UTC</pubDate>
      <author>Trisha Gee</author>
      <guid>http://trishagee.github.io/post/validation_with_spring_modules_validation</guid>
      <description>&lt;p&gt;So if java generics slightly &lt;a href=&#34;http://mechanitis.livejournal.com/6783.html&#34;&gt;disappointed me lately&lt;/a&gt;, what have I found cool?&lt;br/&gt;&lt;br/&gt;I&amp;rsquo;m currently working on a web application using &lt;a href=&#34;http://www.springframework.org/docs/reference/mvc.html&#34;&gt;Spring MVC&lt;/a&gt;, which probably doesn&amp;rsquo;t come as a big surprise, it seems to be all the rage these days.  Since this is my baby, I got to call the shots as to a lot of the framework choices.  When it came to looking at implementing validation, I refused to believe I&amp;rsquo;d have to go through the primitive process of looking at all the values on the request and deciding if they pass muster, with some huge &lt;code&gt;if&lt;/code&gt; statement.  Even with Spring&amp;rsquo;s rather marvelous &lt;a href=&#34;http://static.springframework.org/spring/docs/2.0.x/reference/validation.html&#34;&gt;binding and validation mechanisms&lt;/a&gt; to take the worst of the tasks off you, it still looked like it would be a bit of a chore.  Given all the cool things you can do with AOP etc I figured someone somewhere must&amp;rsquo;ve implemented an annotations-based validation plugin for Spring.&lt;br/&gt;&lt;br/&gt;&lt;a href=&#34;https://springmodules.dev.java.net/docs/reference/0.8/html_single/#validation&#34;&gt;And they have&lt;/a&gt;.  And there&amp;rsquo;s actually a reasonable amount of information about how to set it up and get it working.  The problem is that it&amp;rsquo;s pretty flexible and has a lot of different options, so when you are running Java 1.5 and Spring 2.0, and actually want to use the validation in a simple, straightfoward fashion, the setup instructions get lost.&lt;br/&gt;&lt;br/&gt;So here&amp;rsquo;s my record so I don&amp;rsquo;t forget in future how I did it.&lt;br/&gt;&lt;br/&gt;As a brief summary for those who may not be familiar with Spring, or for those who need reminding (no doubt me in a few months when I&amp;rsquo;ve completely forgetten what I was working on), Spring provides a &lt;code&gt;Validator&lt;/code&gt; interface that you can use to easily plug validation into your application.  In the context of web applications, you create your various &lt;code&gt;Validators&lt;/code&gt; and in your application context XML file you tell your Controllers to use those validators on form submission (for example).&lt;br/&gt;&lt;br/&gt;Spring Modules validation provides a bunch of generic validation out of the box for all the tedious, standard stuff - length validation, mandatory fields, valid e-mail addresses etc (&lt;a href=&#34;https://springmodules.dev.java.net/docs/reference/0.8/html_single/#d0e8935&#34;&gt;details here&lt;/a&gt;).  And you can plug this straight into your application by using annotations.  How?  Easy.&lt;br/&gt;&lt;br/&gt;This is my outline application context file:&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;br/&gt;&amp;lt;beans xmlns=&amp;quot; &lt;a href=&#34;http://www.springframework.org/schema/beans&amp;amp;quot;&amp;lt;br/&amp;gt;&#34;&gt;http://www.springframework.org/schema/beans&amp;amp;quot;&amp;lt;br/&amp;gt;&lt;/a&gt; xmlns:xsi=&amp;quot;&lt;a href=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/a&gt; &amp;quot;&lt;br/&gt;   xmlns:vld=&amp;quot;&lt;a href=&#34;http://www.springmodules.org/validation/bean/validator&#34;&gt;http://www.springmodules.org/validation/bean/validator&lt;/a&gt; &amp;quot;&lt;br/&gt;  xsi:schemaLocation=&amp;quot;&lt;a href=&#34;http://www.springframework.org/schema/beans&#34;&gt;http://www.springframework.org/schema/beans&lt;/a&gt; &lt;a href=&#34;http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&amp;lt;br/&amp;gt;&#34;&gt;http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&amp;lt;br/&amp;gt;&lt;/a&gt;                      &lt;a href=&#34;http://www.springmodules.org/validation/bean/validator&#34;&gt;http://www.springmodules.org/validation/bean/validator&lt;/a&gt; &lt;a href=&#34;http://www.springmodules.org/validation/bean/validator.xsd&amp;amp;quot;&amp;amp;gt;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&#34;&gt;http://www.springmodules.org/validation/bean/validator.xsd&amp;amp;quot;&amp;amp;gt;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;&lt;/a&gt;   &amp;lt;vld:annotation-based-validator id=&amp;quot;validator&amp;quot; /&amp;gt;&lt;br/&gt;&lt;br/&gt; &amp;lt;!&amp;ndash; Load messages &amp;ndash;&amp;gt;&lt;br/&gt;   &amp;lt;bean id=&amp;quot;messageSource&amp;quot;&lt;br/&gt;      class=&amp;quot;org.springframework.context.support.ResourceBundleMessageSource&amp;quot;&amp;gt;&lt;br/&gt;      &amp;lt;property name=&amp;quot;basenames&amp;quot; value=&amp;quot;messages,errors&amp;quot; /&amp;gt;&lt;br/&gt;    &amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;br/&gt; &amp;lt;!&amp;ndash; Bean initialisation for validation. You can put these explicitly into your controllers or set to autowire by name or type &amp;ndash;&amp;gt;&lt;br/&gt;   &amp;lt;bean id=&amp;quot;messageCodesResolver&amp;quot;&lt;br/&gt;       class=&amp;quot;org.springmodules.validation.bean.converter.ModelAwareMessageCodesResolver&amp;quot; /&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/beans&amp;gt;&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Really all you&amp;rsquo;re interested in is the addition of the validation namespace and schema at the top of the file, and the &lt;code&gt;&amp;lt;vld:annotation-based-validator id=&amp;quot;validator&amp;quot; /&amp;gt;&lt;/code&gt; line which is your actual validator.  The other sections are a message source so your error codes can have meaningful messages and a MessageCodeResolver to make use of these.&lt;br/&gt;&lt;br/&gt;Eclipse does seem to moan about the way the springmodules schema is referenced, but when you actually start Tomcat up it seems happy enough.&lt;br/&gt;&lt;br/&gt;I&amp;rsquo;ve chosen to give the validator the ID &lt;code&gt;validator&lt;/code&gt; because I turned autowire by name on so that all my controllers picked up this validation by default.  Note: autowire can be a little bit dangerous and I&amp;rsquo;ve actually turned it off now because I had a &lt;code&gt;validator&lt;/code&gt; bean and a &lt;code&gt;validators&lt;/code&gt; list in the context file and my poor SimpleFormController controllers were getting a bit confused over which one to use (in truth, the single validator was overwriting the list, which was not what I was after at all).&lt;br/&gt;&lt;br/&gt;Anyway.  Now what?  We have a validator and we&amp;rsquo;ve probably wired it into the relevant controllers, either by autowiring them or poking it specifically into our controllers like this:&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;    &amp;lt;bean id=&amp;quot;somePersonController&amp;quot;&lt;br/&gt;       class=&amp;quot;com.mechanitis.examples.validation.controller.MyPersonController&amp;quot;&amp;gt;&lt;br/&gt;     &amp;lt;property name=&amp;quot;commandClass&amp;quot;&lt;br/&gt;         value=&amp;quot;com.mechanitis.examples.validation.command.PersonCommand&amp;quot; /&amp;gt;&lt;br/&gt;       &amp;lt;property name=&amp;quot;formView&amp;quot; value=&amp;quot;person&amp;quot; /&amp;gt;&lt;br/&gt;      &amp;lt;property name=&amp;quot;successView&amp;quot; value=&amp;quot;success&amp;quot; /&amp;gt;&lt;br/&gt;      &amp;lt;property name=&amp;quot;validator&amp;quot; ref=&amp;quot;validator&amp;quot;/&amp;gt;&lt;br/&gt; &amp;lt;/bean&amp;gt;&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Next step is to add some validation rules.  &lt;a href=&#34;https://springmodules.dev.java.net/docs/reference/0.8/html_single/#d0e8930&#34;&gt;The documentation&lt;/a&gt; will show you how to do this using an XML file, which you&amp;rsquo;re perfectly welcome to do.  However what I wanted to show is how to use annotations on your command object to declare your validation.  So here you are:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;import org.springmodules.validation.bean.conf.loader.annotation.handler.CascadeValidation;&lt;br/&gt;import org.springmodules.validation.bean.conf.loader.annotation.handler.Email;&lt;br/&gt;import org.springmodules.validation.bean.conf.loader.annotation.handler.Length;&lt;br/&gt;import org.springmodules.validation.bean.conf.loader.annotation.handler.Min;&lt;br/&gt;import org.springmodules.validation.bean.conf.loader.annotation.handler.NotNull;&lt;br/&gt;&lt;br/&gt;public class PersonCommand {&lt;br/&gt;    private static final int NAME_MAX_LENGTH = 50;&lt;br/&gt;&lt;br/&gt;    @NotNull&lt;br/&gt;    @Length(min = 1, max = NAME_MAX_LENGTH)&lt;br/&gt;    private String name;&lt;br/&gt;&lt;br/&gt;    @Min(value=1)&lt;br/&gt;    private Long age;&lt;br/&gt;    &lt;br/&gt;    @Email&lt;br/&gt;    private String eMail;&lt;br/&gt;&lt;br/&gt;    @CascadeValidation&lt;br/&gt;    private RelationshipCommand relationship = new RelationshipCommand();&lt;br/&gt;&lt;br/&gt;    private String action;&lt;br/&gt;&lt;br/&gt;    //insert getters and setters etc&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;Note that &lt;code&gt;@CascadeValidation&lt;/code&gt; tells the validator to run validation on the enclosed secondary Command.&lt;br/&gt;&lt;br/&gt;This is just a simple example obviously.  But hopefully you can see that now you&amp;rsquo;ve got the validator set up correctly in your application context file, all you need to cover 90% of your validation needs is to tag the relevant fields with the type of validation you want.  If you want to get really clever, the validator supports &lt;a href=&#34;https://springmodules.dev.java.net/docs/reference/0.8/html_single/#valang&#34;&gt;Valang&lt;/a&gt; which allows you to write simple rules.  For example, if I only want to validate the name when I&amp;rsquo;m saving the person rather than passing the command around for some other purpose, I might change the annotations on the name field:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;    @NotNull(applyIf=&amp;ldquo;action EQUALS &amp;lsquo;savePerson&amp;rsquo;&amp;rdquo;)&lt;br/&gt;    @Length(min = 1, max = NAME_MAX_LENGTH, applyIf=&amp;ldquo;action EQUALS &amp;lsquo;savePerson&amp;rsquo;&amp;rdquo;)&lt;br/&gt;    private String name;&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;That&amp;rsquo;s the basics.  Before I let you go off and play though, a word about error messages.  As usual with Spring validators, you can specify pretty messages to be displayed to the user when things go wrong.  In my application context file above you should see that I&amp;rsquo;ve specified a properties file called errors.  In this file you can map your error codes to the message to display.  When using the spring modules validation I found the error codes generated were like the ones below so you might have an errors.properties file that looks like this:&lt;br/&gt;&lt;br/&gt;&lt;pre&gt;&lt;br/&gt;# *** Errors for the Person screens&lt;br/&gt;PersonCommand.age[min]=An age should be entered&lt;br/&gt;PersonCommand.name[length]=Person name should be between 1 and 50 characters&lt;br/&gt;# etc etc&lt;br/&gt;&lt;br/&gt;# *** General errors&lt;br/&gt;not.null=This field cannot be empty&lt;br/&gt;&lt;/pre&gt;&lt;br/&gt;&lt;br/&gt;Go play.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
